var documenterSearchIndex = {"docs":
[{"location":"DMRG.html#DMRG","page":"DMRG","title":"DMRG","text":"","category":"section"},{"location":"DMRG.html","page":"DMRG","title":"DMRG","text":"dmrg","category":"page"},{"location":"DMRG.html#ITensorMPS.dmrg","page":"DMRG","title":"ITensorMPS.dmrg","text":"dmrg(H::MPO, psi0::MPS; kwargs...)\ndmrg(H::MPO, psi0::MPS, sweeps::Sweeps; kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, represented as a matrix product operator (MPO).\n\ndmrg(Hs::Vector{MPO}, psi0::MPS; kwargs...)\ndmrg(Hs::Vector{MPO}, psi0::MPS, sweeps::Sweeps; kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H. This version of dmrg accepts a representation of H as a Vector of MPOs, Hs = [H1, H2, H3, ...] such that H is defined as H = H1 + H2 + H3 + ... Note that this sum of MPOs is not actually computed; rather the set of MPOs [H1,H2,H3,..] is efficiently looped over at each step of the DMRG algorithm when optimizing the MPS.\n\ndmrg(H::MPO, Ms::Vector{MPS}, psi0::MPS; weight=1.0, kwargs...)\ndmrg(H::MPO, Ms::Vector{MPS}, psi0::MPS, sweeps::Sweeps; weight=1.0, kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, subject to the constraint that the MPS is orthogonal to each of the MPS provided in the Vector Ms. The orthogonality constraint is approximately enforced by adding to H terms of the form w|M1><M1| + w|M2><M2| + ... where Ms=[M1, M2, ...] and w is the \"weight\" parameter, which can be adjusted through the optional weight keyword argument.\n\nnote: Note\ndmrg will report the energy of the operator H + w|M1><M1| + w|M2><M2| + ..., not the operator H. If you want the expectation value of the MPS eigenstate with respect to just H, you can compute it yourself with an observer or after DMRG is run with inner(psi', H, psi).\n\nThe MPS psi0 is used to initialize the MPS to be optimized.\n\nThe number of sweeps of thd DMRG algorithm is controlled by passing the nsweeps keyword argument. The keyword arguments maxdim, cutoff, noise, and mindim can also be passed to control the cost versus accuracy of the algorithm - see below for details.\n\nAlternatively the number of sweeps and accuracy parameters can be passed through a Sweeps object, though this interface is no longer preferred.\n\nReturns:\n\nenergy::Number - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\nKeyword arguments:\n\nnsweeps::Int - number of \"sweeps\" of DMRG to perform\n\nOptional keyword arguments:\n\nmaxdim - integer or array of integers specifying the maximum size  allowed for the bond dimension or rank of the MPS being optimized.\ncutoff - float or array of floats specifying the truncation error cutoff  or threshold to use for truncating the bond dimension or rank of the MPS.\neigsolve_krylovdim::Int = 3 - maximum dimension of Krylov space used to  locally solve the eigenvalue problem. Try setting to a higher value if  convergence is slow or the Hamiltonian is close to a critical point. [krylovkit]\neigsolve_tol::Number = 1e-14 - Krylov eigensolver tolerance. [krylovkit]\neigsolve_maxiter::Int = 1 - number of times the Krylov subspace can be  rebuilt. [krylovkit]\neigsolve_verbosity::Int = 0 - verbosity level of the Krylov solver.  Warning: enabling this will lead to a lot of outputs to the terminal. [krylovkit]\nishermitian=true - boolean specifying if dmrg should assume the MPO (or more  general linear operator) represents a Hermitian matrix. [krylovkit]\nnoise - float or array of floats specifying strength of the \"noise term\"  to use to aid convergence.\nmindim - integer or array of integers specifying the minimum size of the  bond dimension or rank, if possible.\noutputlevel::Int = 1 - larger outputlevel values make DMRG print more  information and 0 means no output.\nobserver - object implementing the Observer interface  which can perform measurements and stop DMRG early.\nwrite_when_maxdim_exceeds::Int - when the allowed maxdim exceeds this  value, begin saving tensors to disk to free RAM memory in large calculations\nwrite_path::String = tempdir() - path to use to save files to disk  (to save RAM) when maxdim exceeds the write_when_maxdim_exceeds option, if set\n\n[krylovkit]: The dmrg function in ITensors.jl currently uses the eigsolve function in KrylovKit.jl as the internal the eigensolver. See the KrylovKit.jl documention on the eigsolve function for more details: KrylovKit.eigsolve.\n\n\n\n\n\n","category":"function"},{"location":"faq/QN.html#Quantum-Number-Frequently-Asked-Questions","page":"Quantum Number (QN) FAQs","title":"Quantum Number Frequently Asked Questions","text":"","category":"section"},{"location":"faq/QN.html#Can-I-mix-different-types-of-quantum-numbers-within-the-same-system?","page":"Quantum Number (QN) FAQs","title":"Can I mix different types of quantum numbers within the same system?","text":"","category":"section"},{"location":"faq/QN.html","page":"Quantum Number (QN) FAQs","title":"Quantum Number (QN) FAQs","text":"Yes, you can freely mix quantum numbers (QNs) of different types. For example, you can make the sites of your systems alternate between sites carrying spin \"Sz\" QNs and fermion sites carrying particle number \"Nf\" QNs. The QNs will not mix with each other and will separately be conserved to the original value you set for your initial wavefunction.","category":"page"},{"location":"faq/QN.html#How-can-I-separately-conserve-QNs-which-have-the-same-name?","page":"Quantum Number (QN) FAQs","title":"How can I separately conserve QNs which have the same name?","text":"","category":"section"},{"location":"faq/QN.html","page":"Quantum Number (QN) FAQs","title":"Quantum Number (QN) FAQs","text":"If you have two physically distinct types of sites, such as \"Qudit\" sites, but which carry identically named QNs called \"Number\", and you want the qudit number to be separately conserved within each type of site, you must make the QN names different for the two types of sites.","category":"page"},{"location":"faq/QN.html","page":"Quantum Number (QN) FAQs","title":"Quantum Number (QN) FAQs","text":"For example, the following line of code will make an array of site indices with the qudit number QN having the name \"Number_odd\" on odd sites and \"Number_even\" on even sites:","category":"page"},{"location":"faq/QN.html","page":"Quantum Number (QN) FAQs","title":"Quantum Number (QN) FAQs","text":"sites = [isodd(n) ? siteind(\"Qudit\", n; dim=10, conserve_qns=true, qnname_number=\"Number_odd\")\n                  : siteind(\"Qudit\", n; dim=2, conserve_qns=true, qnname_number=\"Number_even\")\n                  for n in 1:2*L]","category":"page"},{"location":"faq/QN.html","page":"Quantum Number (QN) FAQs","title":"Quantum Number (QN) FAQs","text":"(You may have to collapse the above code into a single line for it to run properly.)","category":"page"},{"location":"DMRGObserver.html#DMRGObserver","page":"DMRGObserver","title":"DMRGObserver","text":"","category":"section"},{"location":"DMRGObserver.html","page":"DMRGObserver","title":"DMRGObserver","text":"A DMRGObserver is a type of observer which offers certain useful, general purpose capabilities for DMRG calculations such as measuring custom local observables at each step and stopping DMRG early if certain energy convergence conditions are met.","category":"page"},{"location":"DMRGObserver.html#Sample-Usage","page":"DMRGObserver","title":"Sample Usage","text":"","category":"section"},{"location":"DMRGObserver.html","page":"DMRGObserver","title":"DMRGObserver","text":"In the following example, we have already made a Hamiltonian MPO H and initial MPS psi0 for a system of spins whose sites have an associated \"Sz\" operator defined. We construct a DMRGObserver which measures \"Sz\" on each site at each step of DMRG, and also stops the calculation early if the energy no longer changes to a relative precision of 1E-7.","category":"page"},{"location":"DMRGObserver.html","page":"DMRGObserver","title":"DMRGObserver","text":"Sz_observer = DMRGObserver([\"Sz\"],sites,energy_tol=1E-7)\n\nenergy, psi = dmrg(H,psi0,sweeps,observer=Sz_observer)\n\nfor (sw,Szs) in enumerate(measurements(Sz_observer)[\"Sz\"])\n  println(\"Total Sz after sweep $sw = \", sum(Szs)/N)\nend","category":"page"},{"location":"DMRGObserver.html#Constructors","page":"DMRGObserver","title":"Constructors","text":"","category":"section"},{"location":"DMRGObserver.html","page":"DMRGObserver","title":"DMRGObserver","text":"DMRGObserver(;energy_tol::Float64,minsweeps::Int)\nDMRGObserver(ops::Vector{String},sites::Vector{<:Index};energy_tol::Float64,minsweeps::Int)","category":"page"},{"location":"DMRGObserver.html#ITensorMPS.DMRGObserver-Tuple{}","page":"DMRGObserver","title":"ITensorMPS.DMRGObserver","text":"DMRGObserver(;energy_tol=0.0,\n              minsweeps=2,\n              energy_type=Float64)\n\nConstruct a DMRGObserver by providing the energy tolerance used for early stopping, and minimum number of sweeps that must be done.\n\nOptional keyword arguments:\n\nenergy_tol: if the energy from one sweep to the next no longer changes by more than this amount, stop after the current sweep\nminsweeps: do at least this many sweeps\nenergy_type: type to use when storing energies at each step\n\n\n\n\n\n","category":"method"},{"location":"DMRGObserver.html#ITensorMPS.DMRGObserver-Tuple{Vector{String}, Vector{<:Index}}","page":"DMRGObserver","title":"ITensorMPS.DMRGObserver","text":"DMRGObserver(ops::Vector{String},\n             sites::Vector{<:Index};\n             energy_tol=0.0,\n             minsweeps=2,\n             energy_type=Float64)\n\nConstruct a DMRGObserver, provide an array of ops of operator names which are strings recognized by the op function. Each of these operators will be measured on every site during every step of DMRG and the results recorded inside the DMRGOberver for later analysis. The array sites is the basis of sites used to define the MPS and MPO for the DMRG calculation.\n\nOptionally, one can provide an energy tolerance used for early stopping, and minimum number of sweeps that must be done.\n\nOptional keyword arguments:\n\nenergy_tol: if the energy from one sweep to the next no longer changes by more than this amount, stop after the current sweep\nminsweeps: do at least this many sweeps\nenergy_type: type to use when storing energies at each step\n\n\n\n\n\n","category":"method"},{"location":"DMRGObserver.html#Methods","page":"DMRGObserver","title":"Methods","text":"","category":"section"},{"location":"DMRGObserver.html","page":"DMRGObserver","title":"DMRGObserver","text":"measurements(::DMRGObserver)\nDMRGMeasurement\nenergies(::DMRGObserver)","category":"page"},{"location":"DMRGObserver.html#ITensorMPS.measurements-Tuple{DMRGObserver}","page":"DMRGObserver","title":"ITensorMPS.measurements","text":"measurements(o::DMRGObserver)\n\nAfter using a DMRGObserver object o within a DMRG calculation, retrieve a dictionary of measurement results, with the keys being operator names and values being DMRGMeasurement objects.\n\n\n\n\n\n","category":"method"},{"location":"DMRGObserver.html#ITensorMPS.DMRGMeasurement","page":"DMRGObserver","title":"ITensorMPS.DMRGMeasurement","text":"A DMRGMeasurement object is an alias for Vector{Vector{Float64}}, in other words an array of arrays of real numbers.\n\nGiven a DMRGMeasurement M,the result for the measurement on sweep n and site i as M[n][i].\n\n\n\n\n\n","category":"type"},{"location":"DMRGObserver.html#ITensorMPS.energies-Tuple{DMRGObserver}","page":"DMRGObserver","title":"ITensorMPS.energies","text":"energies(o::DMRGObserver)\n\nAfter using a DMRGObserver object o within a DMRG calculation, retrieve an array of the energy after each sweep.\n\n\n\n\n\n","category":"method"},{"location":"HDF5FileFormats.html#mps_hdf5","page":"HDF5 File Formats","title":"MPS","text":"","category":"section"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"HDF5 file format for ITensorMPS.MPS","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"Attributes:","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"\"version\" = 1\n\"type\" = \"MPS\"","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"Datasets and Subgroups:","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"\"length\" [integer] = number of tensors of the MPS\n\"rlim\" [integer] = right orthogonality limit\n\"llim\" [integer] = left orthogonality limit\n\"MPS[n]\" [group,ITensor] = each of these groups, where n=1,...,length, stores the nth ITensor of the MPS","category":"page"},{"location":"HDF5FileFormats.html#mpo_hdf5","page":"HDF5 File Formats","title":"MPO","text":"","category":"section"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"HDF5 file format for ITensorMPS.MPO","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"Attributes:","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"\"version\" = 1\n\"type\" = \"MPO\"","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"Datasets and Subgroups:","category":"page"},{"location":"HDF5FileFormats.html","page":"HDF5 File Formats","title":"HDF5 File Formats","text":"\"length\" [integer] = number of tensors of the MPO\n\"rlim\" [integer] = right orthogonality limit\n\"llim\" [integer] = left orthogonality limit\n\"MPO[n]\" [group,ITensor] = each of these groups, where n=1,...,length, stores the nth ITensor of the MPO","category":"page"},{"location":"tutorials/MPSTimeEvolution.html#MPS-Time-Evolution","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"","category":"section"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"An important application of matrix product state (MPS) tensor networks in physics is computing the time evolution of a quantum state under the dynamics of a Hamiltonian H. An accurate, efficient, and simple way to time evolve a matrix product state (MPS) is by using a Trotter decomposition of the time evolution operator U(t) = e^-i H t.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"The technique we will use is \"time evolving block decimation\" (TEBD). More simply it is just the idea of decomposing the time-evolution operator into a circuit of quantum 'gates' (two-site unitaries) using the Trotter-Suzuki approximation and applying these gates in a controlled way to an MPS.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Let's see how to set up and run a TEBD calculation using ITensor.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"The Hamiltonian H we will use is the one-dimensional Heisenberg model which is given by:","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"beginaligned\nH  = sum_j=1^N-1 mathbfS_j cdot mathbfS_j+1  \n = sum_j=1^N-1 S^z_j S^z_j+1 + frac12 S^+_j S^-_j+1 + frac12 S^-_j S^+_j+1\nendaligned","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"The TEBD Method","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"When the Hamiltonian, like the one above, is a sum of local terms,","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"H = sum_j h_jj+1","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"where h_jj+1 acts on sites j and j+1, then a Trotter decomposition that is particularly well suited for use with MPS techniques is","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"e^-i tau H approx e^-i h_12 tau2 e^-i h_23 tau2 cdots e^-i h_N-1N tau2\ne^-i h_N-1N tau2 e^-i h_N-2N-1 tau2 cdots e^-i h_12 tau2 + O(tau^3)","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Note the factors of two in each exponential. Each factored exponential is known as a Trotter \"gate\".","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"We can visualize the resulting circuit that will be applied to the MPS as follows:","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"The error in the above decomposition is of order tau^3, so that will be the error accumulated per time step. Because of the time-step error, one takes tau to be small and then applies the above set of operators to an MPS as a single sweep, then does a number (ttau) of sweeps to evolve for a total time t. The total error will therefore scale as tau^2 with this scheme, though other sources of error may dominate for long times, or very small tau, such as truncation errors.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Let's take a look at the code to apply these Trotter gates to an MPS to time evolve it. Then we will break down the steps of the code in more detail.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"ITensor TEBD Time Evolution Code","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Let's look at an entire, working ITensor code that will do this calculation then discuss the main steps. (If you need help running the code below, see the getting started page on running ITensor codes.)","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"using ITensors, ITensorMPS\n\nlet\n  N = 100\n  cutoff = 1E-8\n  tau = 0.1\n  ttotal = 5.0\n\n  # Make an array of 'site' indices\n  s = siteinds(\"S=1/2\", N; conserve_qns=true)\n\n  # Make gates (1,2),(2,3),(3,4),...\n  gates = ITensor[]\n  for j in 1:(N - 1)\n    s1 = s[j]\n    s2 = s[j + 1]\n    hj =\n      op(\"Sz\", s1) * op(\"Sz\", s2) +\n      1 / 2 * op(\"S+\", s1) * op(\"S-\", s2) +\n      1 / 2 * op(\"S-\", s1) * op(\"S+\", s2)\n    Gj = exp(-im * tau / 2 * hj)\n    push!(gates, Gj)\n  end\n  # Include gates in reverse order too\n  # (N,N-1),(N-1,N-2),...\n  append!(gates, reverse(gates))\n\n  # Initialize psi to be a product state (alternating up and down)\n  psi = MPS(s, n -> isodd(n) ? \"Up\" : \"Dn\")\n\n  c = div(N, 2) # center site\n\n  # Compute and print <Sz> at each time step\n  # then apply the gates to go to the next time\n  for t in 0.0:tau:ttotal\n    Sz = expect(psi, \"Sz\"; sites=c)\n    println(\"$t $Sz\")\n\n    t≈ttotal && break\n\n    psi = apply(gates, psi; cutoff)\n    normalize!(psi)\n  end\n\n  return\nend","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Steps of The Code","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"First we setsome parameters, like the system size N and time step tau to use.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"The line s = siteinds(\"S=1/2\",N;conserve_qns=true) defines an array of spin 1/2 tensor indices (Index objects) which will be the site or physical indices of the MPS.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Next we make an empty array gates = ITensor[] that will hold ITensors that will be our Trotter gates. Inside the for n=1:N-1 loop that follows the lines","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"hj =      op(\"Sz\",s1) * op(\"Sz\",s2) +\n    1/2 * op(\"S+\",s1) * op(\"S-\",s2) +\n    1/2 * op(\"S-\",s1) * op(\"S+\",s2)","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"call the op function which reads the \"S=1/2\" tag on our site indices (sites j and j+1) and which then knows that we want the spin 1/ 2 version of the \"Sz\", \"S+\", and \"S-\" operators. The op function returns these operators as ITensors and we tensor product and add them together to compute the operator h_jj+1 defined as","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"h_jj+1 = S^z_j S^z_j+1 + frac12 S^+_j S^-_j+1 + frac12 S^-_j S^+_j+1","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"which we call hj in the code.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"To make the corresponding Trotter gate Gj we exponentiate hj times a factor -i tau2 and then append or push this onto the end of the gate array gates.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Gj = exp(-im * tau/2 * hj)\npush!(gates,Gj)","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Having made the gates for bonds (1,2),(2,3),(3,4), etc. we still need to append the gates in reverse order to complete the correct Trotter formula. Here we can conveniently do that by just calling the Julia append! function and supply a reversed version of the array of gates we have made so far. This can be done in a single line of code append!(gates,reverse(gates)).","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"The line of code psi = MPS(s, n -> isodd(n) ? \"Up\" : \"Dn\") initializes our MPS psi as a product state of alternating up and down spins.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"To carry out the time evolution we loop over the range of times from 0.0 to ttotal in steps of tau, using the Julia range notation 0.0:tau:ttotal to easily set up this loop as for t in 0.0:tau:ttotal.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"Inside the loop, we use the expect function to measure the expected value of the \"Sz\" operator on the center site.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"To evolve the MPS to the next time, we call the function","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"psi = apply(gates, psi; cutoff)","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"which applies the array of ITensors called gates to our current MPS psi, truncating the MPS at each step using the truncation error threshold supplied as the variable cutoff.","category":"page"},{"location":"tutorials/MPSTimeEvolution.html","page":"MPS Time Evolution","title":"MPS Time Evolution","text":"The apply function is smart enough to determine which site indices each gate has, and then figure out where to apply it to our MPS. It automatically handles truncating the MPS and can even handle non-nearest-neighbor gates, though that feature is not used in this example.","category":"page"},{"location":"examples/DMRG.html#DMRG-Code-Examples","page":"DMRG Examples","title":"DMRG Code Examples","text":"","category":"section"},{"location":"examples/DMRG.html#Perform-a-basic-DMRG-calculation","page":"DMRG Examples","title":"Perform a basic DMRG calculation","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Because tensor indices in ITensor have unique identities, before we can make a Hamiltonian or a wavefunction we need to construct a \"site set\" which will hold the site indices defining the physical Hilbert space:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=1\",N)","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Here we have chosen to create a Hilbert space of N spin 1 sites. The string \"S=1\" denotes a special Index tag which hooks into a system that knows \"S=1\" indices have a dimension of 3 and how to create common physics operators like \"Sz\" for them.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Next we'll make our Hamiltonian matrix product operator (MPO). A very convenient way to do this is to use the OpSum helper type which lets us input a Hamiltonian (or any sum of local operators) in similar notation to pencil-and-paper notation:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"os = OpSum()\nfor j=1:N-1\n  os += 0.5,\"S+\",j,\"S-\",j+1\n  os += 0.5,\"S-\",j,\"S+\",j+1\n  os += \"Sz\",j,\"Sz\",j+1\nend\nH = MPO(os,sites)","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"In the last line above we convert the OpSum helper object to an actual MPO.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Before beginning the calculation, we need to specify how many DMRG sweeps to do and what schedule we would like for the parameters controlling the accuracy. These parameters can be specified as follows:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"nsweeps = 5 # number of sweeps is 5\nmaxdim = [10,20,100,100,200] # gradually increase states kept\ncutoff = [1E-10] # desired truncation error","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"The random starting wavefunction psi0 must be defined in the same Hilbert space as the Hamiltonian, so we construct it using the same collection of site indices:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"psi0 = random_mps(sites;linkdims=2)","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Here we have made a random MPS of bond dimension 2. We could have used a random product state instead, but choosing a slightly larger bond dimension can help DMRG avoid getting stuck in local minima. We could also set psi to some specific initial state using the MPS constructor, which is actually required if we were conserving QNs.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Finally, we are ready to call DMRG:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"When the algorithm is done, it returns the ground state energy as the variable energy and an MPS approximation to the ground state as the variable psi.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Below you can find a complete working code that includes all of these steps:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nlet\n  N = 100\n  sites = siteinds(\"S=1\",N)\n\n  os = OpSum()\n  for j=1:N-1\n    os += 0.5,\"S+\",j,\"S-\",j+1\n    os += 0.5,\"S-\",j,\"S+\",j+1\n    os += \"Sz\",j,\"Sz\",j+1\n  end\n  H = MPO(os,sites)\n\n  nsweeps = 5 # number of sweeps is 5\n  maxdim = [10,20,100,100,200] # gradually increase states kept\n  cutoff = [1E-10] # desired truncation error\n\n  psi0 = random_mps(sites;linkdims=2)\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend","category":"page"},{"location":"examples/DMRG.html#Using-a-Custom-Observer-for-DMRG","page":"DMRG Examples","title":"Using a Custom Observer for DMRG","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"An Observer is any object which can be used to perform custom measurements throughout a DMRG calculation and to stop a DMRG calculation early. Because an Observer has access to the entire wavefunction at every step, a wide range of customization is possible.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"For detailed examples of making custom Observers, see the Observer section of the documentation.","category":"page"},{"location":"examples/DMRG.html#DMRG-Calculation-with-Mixed-Local-Hilbert-Space-Types","page":"DMRG Examples","title":"DMRG Calculation with Mixed Local Hilbert Space Types","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"The following fully-working example shows how to set up a calculation mixing S=1/2 and S=1 spins on every other site of a 1D system. The Hamiltonian involves Heisenberg spin interactions with adjustable couplings between sites of the same spin or different spin.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Note that the only difference from a regular ITensor DMRG calculation is that the sites array has Index objects which alternate in dimension and in which physical tag type they carry, whether \"S=1/2\" or \"S=1\". (Try printing out the sites array to see!) These tags tell the OpSum system which local operators to use for these sites when building the Hamiltonian MPO.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nlet\n  N = 100\n\n  # Make an array of N Index objects with alternating\n  # \"S=1/2\" and \"S=1\" tags on odd versus even sites\n  # (The first argument n->isodd(n) ... is an\n  # on-the-fly function mapping integers to strings)\n  sites = siteinds(n->isodd(n) ? \"S=1/2\" : \"S=1\",N)\n\n  # Couplings between spin-half and\n  # spin-one sites:\n  Jho = 1.0 # half-one coupling\n  Jhh = 0.5 # half-half coupling\n  Joo = 0.5 # one-one coupling\n\n  os = OpSum()\n  for j=1:N-1\n    os += 0.5*Jho,\"S+\",j,\"S-\",j+1\n    os += 0.5*Jho,\"S-\",j,\"S+\",j+1\n    os += Jho,\"Sz\",j,\"Sz\",j+1\n  end\n  for j=1:2:N-2\n    os += 0.5*Jhh,\"S+\",j,\"S-\",j+2\n    os += 0.5*Jhh,\"S-\",j,\"S+\",j+2\n    os += Jhh,\"Sz\",j,\"Sz\",j+2\n  end\n  for j=2:2:N-2\n    os += 0.5*Joo,\"S+\",j,\"S-\",j+2\n    os += 0.5*Joo,\"S-\",j,\"S+\",j+2\n    os += Joo,\"Sz\",j,\"Sz\",j+2\n  end\n  H = MPO(os,sites)\n\n  nsweeps = 10\n  maxdim = [10,10,20,40,80,100,140,180,200]\n  cutoff = [1E-8]\n\n  psi0 = random_mps(sites;linkdims=4)\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend","category":"page"},{"location":"examples/DMRG.html#Use-a-Sum-of-MPOs-in-DMRG","page":"DMRG Examples","title":"Use a Sum of MPOs in DMRG","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"One version of the ITensor dmrg function accepts an array of MPOs [H1,H2,H3] (or any number of MPOs you want). This version of DMRG will find the ground state of H1+H2+H3. Internally it does not actually sum these MPOs, but loops over them during each step of the \"eigensolver\" at the core of the DMRG algorithm, so it is usually more efficient than if the MPOs had been summed together into a single MPO.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"To use this version of DMRG, say you have MPOs H1, H2, and H3. Then call DMRG like this:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"energy,psi = dmrg([H1,H2,H3],psi0;nsweeps,maxdim,cutoff)","category":"page"},{"location":"examples/DMRG.html#Make-a-2D-Hamiltonian-for-DMRG","page":"DMRG Examples","title":"Make a 2D Hamiltonian for DMRG","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"You can use the OpSum system to make 2D Hamiltonians much in the same way you make 1D Hamiltonians: by looping over all of the bonds and adding the interactions on these bonds to the OpSum.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"To help with the logic of 2D lattices, ITensor pre-defines some helper functions which return an array of bonds. Each bond object has an \"s1\" field and an \"s2\" field which are the integers numbering the two sites the bond connects. (You can view the source for these functions at this link.)","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"The two provided functions currently are square_lattice and triangular_lattice. It is not hard to write your own similar lattice functions as all they have to do is define an array of ITensors.LatticeBond structs or even a custom struct type you wish to define. We welcome any user contributions of other lattices that ITensor does not currently offer.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Each lattice function takes an optional named argument \"yperiodic\" which lets you request that the lattice should have periodic boundary conditions around the y direction, making the geometry a cylinder.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Full example code:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nlet\n  Ny = 6\n  Nx = 12\n\n  N = Nx*Ny\n\n  sites = siteinds(\"S=1/2\", N;\n                   conserve_qns = true)\n\n  # Obtain an array of LatticeBond structs\n  # which define nearest-neighbor site pairs\n  # on the 2D square lattice (wrapped on a cylinder)\n  lattice = square_lattice(Nx, Ny; yperiodic = false)\n\n  # Define the Heisenberg spin Hamiltonian on this lattice\n  os = OpSum()\n  for b in lattice\n    os += 0.5, \"S+\", b.s1, \"S-\", b.s2\n    os += 0.5, \"S-\", b.s1, \"S+\", b.s2\n    os +=      \"Sz\", b.s1, \"Sz\", b.s2\n  end\n  H = MPO(os,sites)\n\n  state = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\n  # Initialize wavefunction to a random MPS\n  # of bond-dimension 10 with same quantum\n  # numbers as `state`\n  psi0 = random_mps(sites,state;linkdims=20)\n\n  nsweeps = 10\n  maxdim = [20,60,100,100,200,400,800]\n  cutoff = [1E-8]\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend","category":"page"},{"location":"examples/DMRG.html#Compute-excited-states-with-DMRG","page":"DMRG Examples","title":"Compute excited states with DMRG","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"ITensor DMRG accepts additional MPS wavefunctions as a optional, extra argument. These additional 'penalty states' are provided as an array of MPS just after the Hamiltonian, like this:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"energy,psi3 = dmrg(H,[psi0,psi1,psi2],psi3_init;nsweeps,maxdim,cutoff)","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Here the penalty states are [psi0,psi1,psi2]. When these are provided, the DMRG code minimizes the energy of the current MPS while also reducing its overlap (inner product) with the previously provided MPS. If these overlaps become sufficiently small, then the computed MPS is an excited state. So by finding the ground state, then providing it to DMRG as a \"penalty state\" or previous state one can compute the first excited state. Then providing both of these, one can get the second excited state, etc.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"A  keyword argument called weight can also be provided to the dmrg function when penalizing overlaps to previous states. The weight parameter is multiplied by the overlap with the previous states, so sets the size of the penalty. It should be chosen at least as large as the (estimated) gap between the ground and first excited states. Otherwise the optimal value of the weight parameter is not so obvious, and it is best to try various weights during initial test calculations.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Note that when the system has conserved quantum numbers, a superior way to find excited states can be to find ground states of quantum number (or symmetry) sectors other than the one containing the absolute ground state. In that context, the penalty method used below is a way to find higher excited states within the same quantum number sector.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Full Example code:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nlet\n  N = 20\n\n  sites = siteinds(\"S=1/2\",N)\n\n  h = 4.0\n\n  weight = 20*h # use a large weight\n                # since gap is expected to be large\n\n\n  #\n  # Use the OpSum feature to create the\n  # transverse field Ising model\n  #\n  # Factors of 4 and 2 are to rescale\n  # spin operators into Pauli matrices\n  #\n  os = OpSum()\n  for j=1:N-1\n    os -= 4,\"Sz\",j,\"Sz\",j+1\n  end\n  for j=1:N\n    os -= 2*h,\"Sx\",j;\n  end\n  H = MPO(os,sites)\n\n\n  #\n  # Make sure to do lots of sweeps\n  # when finding excited states\n  #\n  nsweeps = 30\n  maxdim = [10,10,10,20,20,40,80,100,200,200]\n  cutoff = [1E-8]\n  noise = [1E-6]\n\n  #\n  # Compute the ground state psi0\n  #\n  psi0_init = random_mps(sites;linkdims=2)\n  energy0,psi0 = dmrg(H,psi0_init;nsweeps,maxdim,cutoff,noise)\n\n  println()\n\n  #\n  # Compute the first excited state psi1\n  #\n  psi1_init = random_mps(sites;linkdims=2)\n  energy1,psi1 = dmrg(H,[psi0],psi1_init;nsweeps,maxdim,cutoff,noise,weight)\n\n  # Check psi1 is orthogonal to psi0\n  @show inner(psi1,psi0)\n\n\n  #\n  # The expected gap of the transverse field Ising\n  # model is given by Eg = 2*|h-1|\n  #\n  # (The DMRG gap will have finite-size corrections)\n  #\n  println(\"DMRG energy gap = \",energy1-energy0);\n  println(\"Theoretical gap = \",2*abs(h-1));\n\n  println()\n\n  #\n  # Compute the second excited state psi2\n  #\n  psi2_init = random_mps(sites;linkdims=2)\n  energy2,psi2 = dmrg(H,[psi0,psi1],psi2_init;nsweeps,maxdim,cutoff,noise,weight)\n\n  # Check psi2 is orthogonal to psi0 and psi1\n  @show inner(psi2,psi0)\n  @show inner(psi2,psi1)\n\n  return\nend","category":"page"},{"location":"examples/DMRG.html#Printing-the-Entanglement-Entropy-at-Each-Step","page":"DMRG Examples","title":"Printing the Entanglement Entropy at Each Step","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"To obtain the entanglement entropy of an MPS at each step during a DMRG calculation, you can use the Observer system to make a custom observer object that prints out this information.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"First we define our custom observer type, EntanglementObserver, and overload the measure! function for it:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nmutable struct EntanglementObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::EntanglementObserver; bond, psi, half_sweep, kwargs...)\n  wf_center, other = half_sweep==1 ? (psi[bond+1],psi[bond]) : (psi[bond],psi[bond+1])\n  U,S,V = svd(wf_center, uniqueinds(wf_center,other))\n  SvN = 0.0\n  for n=1:dim(S, 1)\n    p = S[n,n]^2\n    SvN -= p * log(p)\n  end\n  println(\"  Entanglement across bond $bond = $SvN\")\nend","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"The measure! function grabs certain helpful keywords passed to it by DMRG, such as what bond DMRG has just finished optimizing.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Here is a complete sample code including constructing the observer and passing it to DMRG:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nmutable struct EntanglementObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::EntanglementObserver; bond, psi, half_sweep, kwargs...)\n  wf_center, other = half_sweep==1 ? (psi[bond+1],psi[bond]) : (psi[bond],psi[bond+1])\n  U,S,V = svd(wf_center, uniqueinds(wf_center,other))\n  SvN = 0.0\n  for n=1:dim(S, 1)\n    p = S[n,n]^2\n    SvN -= p * log(p)\n  end\n  println(\"  Entanglement across bond $bond = $SvN\")\nend\n\nlet\n  N = 100\n\n  s = siteinds(\"S=1/2\",N)\n\n  a = OpSum()\n  for n=1:N-1\n    a += \"Sz\",n,\"Sz\",n+1\n    a += 0.5,\"S+\",n,\"S-\",n+1\n    a += 0.5,\"S-\",n,\"S+\",n+1\n  end\n  H = MPO(a,s)\n  psi0 = random_mps(s;linkdims=4)\n\n  nsweeps = 5\n  maxdim = [10,20,80,160]\n  cutoff = 1E-8\n\n  observer = EntanglementObserver()\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff,observer,outputlevel=2)\n\n  return\nend","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Example output:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"...\nSweep 2, half 2, bond (35,36) energy=-44.08644657103751\n  Truncated using cutoff=1.0E-08 maxdim=20 mindim=1\n  Trunc. err=2.54E-07, bond dimension 20\n  Entanglement across bond 35 = 0.7775882479059774\nSweep 2, half 2, bond (34,35) energy=-44.086696891668424\n  Truncated using cutoff=1.0E-08 maxdim=20 mindim=1\n  Trunc. err=2.12E-07, bond dimension 20\n  Entanglement across bond 34 = 0.7103532704635472\nSweep 2, half 2, bond (33,34) energy=-44.08696190368391\n  Truncated using cutoff=1.0E-08 maxdim=20 mindim=1\n  Trunc. err=1.29E-07, bond dimension 20\n  Entanglement across bond 33 = 0.7798362911744212\n...","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"If you only want to see the maximum entanglement during each sweep, you can add a field to the EntanglementObserver object that saves the maximum value encountered so far and keep overwriting this field, printing out the most recently observed maximum at the end of each sweep.","category":"page"},{"location":"examples/DMRG.html#Monitoring-the-Memory-Usage-of-DMRG","page":"DMRG Examples","title":"Monitoring the Memory Usage of DMRG","text":"","category":"section"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"To monitor how much memory (RAM) a DMRG calculation is using while it is running, you can use the Observer system to make a custom observer object that prints out this information. Also the Base.summarysize function, which returns the size in bytes of any Julia object is very helpful here.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"First we define our custom observer type, SizeObserver, and overload the measure! function for it:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nmutable struct SizeObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::SizeObserver; bond, half_sweep, psi, projected_operator, kwargs...)\n  if bond==1 && half_sweep==2\n    psi_size =  Base.format_bytes(Base.summarysize(psi))\n    PH_size =  Base.format_bytes(Base.summarysize(projected_operator))\n    println(\"|psi| = $psi_size, |PH| = $PH_size\")\n  end\nend","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"The measure! function grabs certain helpful keywords passed to it by DMRG, checking if bond==1 && half_sweep==2 so that it only runs when at the end of a full sweep.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"When it runs, it calls Base.summarysize on the wavefunction psi object and the projected_operator object. The projected_operator, which is the matrix (Hamiltonian) wrapped into the current MPS basis, is usually the largest-sized object in a DMRG calculation. The code also uses Base.format_bytes to turn an integer representing bytes into a human-readable string.","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Here is a complete sample code including constructing the observer and passing it to DMRG:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"using ITensors, ITensorMPS\n\nmutable struct SizeObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::SizeObserver; bond, sweep, half_sweep, psi, projected_operator, kwargs...)\n  if bond==1 && half_sweep==2\n    psi_size =  Base.format_bytes(Base.summarysize(psi))\n    PH_size =  Base.format_bytes(Base.summarysize(projected_operator))\n    println(\"After sweep $sweep, |psi| = $psi_size, |PH| = $PH_size\")\n  end\nend\n\nlet\n  N = 100\n\n  s = siteinds(\"S=1/2\",N)\n\n  a = OpSum()\n  for n=1:N-1\n    a += \"Sz\",n,\"Sz\",n+1\n    a += 0.5,\"S+\",n,\"S-\",n+1\n    a += 0.5,\"S-\",n,\"S+\",n+1\n  end\n  H = MPO(a,s)\n  psi0 = random_mps(s;linkdims=4)\n\n  nsweeps = 5\n  maxdim = [10,20,80,160]\n  cutoff = 1E-8\n\n  obs = SizeObserver()\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff,observer=obs)\n\n  return\nend","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"Example output:","category":"page"},{"location":"examples/DMRG.html","page":"DMRG Examples","title":"DMRG Examples","text":"After sweep 1, |psi| = 211.312 KiB, |PH| = 593.984 KiB\nAfter sweep 1 energy=-43.95323393592883  maxlinkdim=10 maxerr=8.26E-06 time=0.098\nAfter sweep 2, |psi| = 641.000 KiB, |PH| = 1.632 MiB\nAfter sweep 2 energy=-44.10791340895817  maxlinkdim=20 maxerr=7.39E-07 time=0.132\nAfter sweep 3, |psi| = 1.980 MiB, |PH| = 5.066 MiB\nAfter sweep 3 energy=-44.12593605906466  maxlinkdim=44 maxerr=9.96E-09 time=0.256\nAfter sweep 4, |psi| = 2.863 MiB, |PH| = 7.246 MiB\nAfter sweep 4 energy=-44.127710946536645  maxlinkdim=56 maxerr=9.99E-09 time=0.445\nAfter sweep 5, |psi| = 3.108 MiB, |PH| = 7.845 MiB\nAfter sweep 5 energy=-44.127736798226536  maxlinkdim=57 maxerr=9.98E-09 time=0.564","category":"page"},{"location":"Observer.html#observer","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"","category":"section"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"An observer is an object which can be passed to the ITensor DMRG algorithm, to allow measurements to be performed throughout the DMRG calculation and to set conditions for early stopping of DMRG.","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"The only requirement of an observer is that it is a subtype of AbstractObserver. But to do something interesting, it should also overload at least one the methods measure! or checkdone!.","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"A general purpose observer type called DMRGObserver is included with ITensors which already provides some quite useful features. It accepts a list of strings naming local operators to be measured at each step of DMRG, with the results saved for later analysis. It also accepts an optional energy precision, and stops a DMRG calculation early if the energy no longer changes to this precision. For more details about the DMRGObserver type, see the DMRGObserver documentation page.","category":"page"},{"location":"Observer.html#Defining-a-Custom-Observer","page":"Observer System for DMRG","title":"Defining a Custom Observer","text":"","category":"section"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"To define a custom observer, just make a struct with any name and internal fields you would like, and make this struct a subtype of AbstractObserver.","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"For example, let's make a type called DemoObserver as:","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"using ITensors, ITensorMPS\n\nmutable struct DemoObserver <: AbstractObserver\n   energy_tol::Float64\n   last_energy::Float64\n\n   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)\nend\n","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"In this minimal example, our DemoObserver contains a field energy_tol which we can use to set an early-stopping condition for DMRG, and an field last_energy which our observer will use internally to keep track of changes to the energy after each sweep.","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"Now to give our DemoObserver type a useful behavior we need to define overloads of the methods measure! and checkdone!.","category":"page"},{"location":"Observer.html#Overloading-the-checkdone!-method","page":"Observer System for DMRG","title":"Overloading the checkdone! method","text":"","category":"section"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"Let's start with the checkdone! method. After each sweep of DMRG, the checkdone! method is passed the observer object, as well as a set of keyword arguments which currently include:","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"energy: the current energy\npsi: the current wavefunction MPS\nsweep: the number of the sweep that just finished\noutputlevel: an integer stating the desired level of output","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"If the checkdone! function returns true, then the DMRG routine stops (recall that checkdone! is called only at the end of a sweep).","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"In our example, we will just compare the energy keyword argument to the last_energy variable held inside the DemoObserver:","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"function ITensorMPS.checkdone!(o::DemoObserver;kwargs...)\n  sw = kwargs[:sweep]\n  energy = kwargs[:energy]\n  if abs(energy-o.last_energy)/abs(energy) < o.energy_tol\n    println(\"Stopping DMRG after sweep $sw\")\n    return true\n  end\n  # Otherwise, update last_energy and keep going\n  o.last_energy = energy\n  return false\nend","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"(Recall that in order to properly overload the default behavior, the checkdone! method has to be imported from the ITensors module or preceded with ITensors.)","category":"page"},{"location":"Observer.html#Overloading-the-measure!-method","page":"Observer System for DMRG","title":"Overloading the measure! method","text":"","category":"section"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"The other method that an observer can overload is measure!. This method is called at every step of DMRG, so at every site and for every sweep. The measure! method is passed the current observer object and a set of keyword arguments which include:","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"energy: the energy after the current step of DMRG\npsi: the current wavefunction MPS\nbond: the bond b that was just optimized, corresponding to sites (b,b+1) in the two-site DMRG algorithm\nsweep: the current sweep number\nsweep_is_done: true if at the end of the current sweep, otherwise false\nhalf_sweep: the half-sweep number, equal to 1 for a left-to-right, first half sweep, or 2 for the second, right-to-left half sweep\nspec: the Spectrum object returned from factorizing the local superblock wavefunction tensor in two-site DMRG\noutputlevel: an integer specifying the amount of output to show\nprojected_operator: projection of the linear operator into the current MPS basis","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"For our minimal DemoObserver example here, we will just make a measure! function that prints out some of the information above, but in a more realistic setting one could use the MPS psi to perform essentially arbitrary measurements.","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"function ITensorMPS.measure!(o::DemoObserver; kwargs...)\n  energy = kwargs[:energy]\n  sweep = kwargs[:sweep]\n  bond = kwargs[:bond]\n  outputlevel = kwargs[:outputlevel]\n\n  if outputlevel > 0\n    println(\"Sweep $sweep at bond $bond, the energy is $energy\")\n  end\nend","category":"page"},{"location":"Observer.html#Calling-DMRG-with-the-Custom-Observer","page":"Observer System for DMRG","title":"Calling DMRG with the Custom Observer","text":"","category":"section"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"After defining an observer type and overloading at least one of the methods checkdone! or measure! for it, one can construct an object of this type and pass it to the ITensor dmrg function using the observer keyword argument.","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"Continuing with our DemoObserver example above:","category":"page"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"obs = DemoObserver(1E-4) # use an energy tolerance of 1E-4\nenergy, psi = dmrg(H,psi0,sweeps; observer=obs, outputlevel=1)","category":"page"},{"location":"Observer.html#Complete-Sample-Code","page":"Observer System for DMRG","title":"Complete Sample Code","text":"","category":"section"},{"location":"Observer.html","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"using ITensors, ITensorMPS\n\nmutable struct DemoObserver <: AbstractObserver\n   energy_tol::Float64\n   last_energy::Float64\n\n   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)\nend\n\nfunction ITensorMPS.checkdone!(o::DemoObserver;kwargs...)\n  sw = kwargs[:sweep]\n  energy = kwargs[:energy]\n  if abs(energy-o.last_energy)/abs(energy) < o.energy_tol\n    println(\"Stopping DMRG after sweep $sw\")\n    return true\n  end\n  # Otherwise, update last_energy and keep going\n  o.last_energy = energy\n  return false\nend\n\nfunction ITensorMPS.measure!(o::DemoObserver; kwargs...)\n  energy = kwargs[:energy]\n  sweep = kwargs[:sweep]\n  bond = kwargs[:bond]\n  outputlevel = kwargs[:outputlevel]\n\n  if outputlevel > 0\n    println(\"Sweep $sweep at bond $bond, the energy is $energy\")\n  end\nend\n\nlet\n  N = 10\n  etol = 1E-4\n\n  s = siteinds(\"S=1/2\",N)\n\n  a = OpSum()\n  for n=1:N-1\n    a += \"Sz\",n,\"Sz\",n+1\n    a += 0.5,\"S+\",n,\"S-\",n+1\n    a += 0.5,\"S-\",n,\"S+\",n+1\n  end\n  H = MPO(a,s)\n  psi0 = random_mps(s;linkdims=4)\n\n  nsweeps = 5\n  cutoff = 1E-8\n  maxdim = [10,20,100]\n\n  obs = DemoObserver(etol)\n\n  println(\"Starting DMRG\")\n  energy, psi = dmrg(H,psi0; nsweeps, cutoff, maxdim, observer=obs, outputlevel=1)\n\n  return\nend","category":"page"},{"location":"examples/MPSandMPO.html#MPS-and-MPO-Examples","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"The following examples demonstrate operations available in ITensor to work with matrix product state (MPS) (or tensor train) and matrix product operator (MPO) tensor networks.","category":"page"},{"location":"examples/MPSandMPO.html#Creating-an-MPS-from-a-Tensor","page":"MPS and MPO Examples","title":"Creating an MPS from a Tensor","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"A matrix product state (MPS) made of N tensors, each with one site or physical index, is a way of representing a single tensor with N indices. One way of obtaining the MPS form of an N-index tensor T is by repeatedly factorizing T into N separate tensors using a factorization such as the Singular Value Decomposition (SVD). This algorithm for obtaining an MPS is known in the mathematics literature as the \"tensor train SVD\" or \"TT-SVD\" algorithm.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"To turn an N-index (order-N) tensor T into an MPS, you can just construct an MPS by passing T as the first argument, along with keyword arguments that control the approximations used in factorizing T. Let's look at a few specific cases.","category":"page"},{"location":"examples/MPSandMPO.html#ITensor-to-MPS-Example","page":"MPS and MPO Examples","title":"ITensor to MPS Example","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"If you have a tensor T which is an ITensor and has indices i,j,k,l,m, you can create an MPS approximation of T where the MPS has site indices i,j,k,l,m as follows:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"cutoff = 1E-8\nmaxdim = 10\nT = random_itensor(i,j,k,l,m)\nM = MPS(T,(i,j,k,l,m);cutoff=cutoff,maxdim=maxdim)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Here we used a random ITensor for illustrative purposes, but it could be any ITensor and typically tensors with additional structure are more well approximated by MPS.","category":"page"},{"location":"examples/MPSandMPO.html#Julia-Tensor-to-MPS-Example","page":"MPS and MPO Examples","title":"Julia Tensor to MPS Example","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Another situation could be where you have a Julia array or Julia tensor of dimension d^N and want to approximate it as an MPS with N site indices, each of dimension d. For example, we could have the following random Julia array of dimension 2times 2times 2 times 2 times 2:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"d = 2\nN = 5\nA = randn(d,d,d,d,d)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Alternatively, the array could be just a one dimensional array of length d^N:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"A = randn(d^N)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"To convert this array to an MPS, we will first need a collection of Index objects to use as the site indices of the MPS. We can conveniently construct an array of four indices of dimension 2 as follows:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"sites = siteinds(d,N)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Finally, we can pass our array A and our sites to the MPS constructor along with parameters controlling the truncation level of the factorizations used:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"cutoff = 1E-8\nmaxdim = 10\nM = MPS(A,sites;cutoff=cutoff,maxdim=maxdim)","category":"page"},{"location":"examples/MPSandMPO.html#Obtaining-Elements-of-a-Tensor-Represented-by-an-MPS","page":"MPS and MPO Examples","title":"Obtaining Elements of a Tensor Represented by an MPS","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"A matrix product state (MPS) or tensor train (TT) is a format for representing a large tensor having N indices in terms of N smaller tensors. Given an MPS represeting a tensor T we can obtain a particular element T^s_1 s_2 s_3 cdots s_N of that tensor using code similar to the following code below.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"In the example code below we will obtain the element T^1211212221 of the tensor T which is (implicitly) defined by the MPS psi:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"using ITensors, ITensorMPS\nlet # hide\nN = 10\ns = siteinds(2,N)\nchi = 4\npsi = random_mps(s;linkdims=chi)\n\n# Make an array of integers of the element we\n# want to obtain\nel = [1,2,1,1,2,1,2,2,2,1]\n\nV = ITensor(1.)\nfor j=1:N\n  V *= (psi[j]*state(s[j],el[j]))\nend\nv = scalar(V)\n\n# v is the element we wanted to obtain:\n@show v\nend # hide","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"The call to state(s[j],el[j]) in the code above makes a single-index ITensor with the Index s[j] and the entry at location el[j] set to 1.0, with all other entries set to 0.0. Contracting this tensor with the MPS tensor at site j can be viewed as \"clamping\" or \"fixing\" the index to a set value. The resulting tensors are contracted sequentially, overwriting the ITensor V, and the final scalar value of V is the tensor element we seek.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"See below for a visual depiction of what the above code is doing:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html#Expected-Value-of-Local-Operators","page":"MPS and MPO Examples","title":"Expected Value of Local Operators","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"When using an MPS to represent a quantum wavefunction psirangle a common operation is computing the expected value langlepsihatA_jpsirangle of a local operator hatA_j acting on site j. This can be accomplished efficiently and conveniently using the expect function as:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Avals = expect(psi,\"A\")","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"where \"A\" must be an operator associated with the physical site type, or site tags, of the sites of the MPS psi. For example, the operator name could be \"Sz\" for spin sites or \"Ntot\" for electron sites. (For more information about defining such operators yourself, see the section on Extending op Function Definitions.)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"As a concrete example, consider computing the expectation value of S^z_j on every site of an MPS representing a system of N spins of size S=12. In the following example we will use a random MPS of bond dimension chi=4 but the MPS could be obtained other ways such as through a DMRG calculation.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"using ITensors, ITensorMPS\nN = 10\nchi = 4\nsites = siteinds(\"S=1/2\",N)\npsi = random_mps(sites;linkdims=chi)\nmagz = expect(psi,\"Sz\")\nfor (j,mz) in enumerate(magz)\n    println(\"$j $mz\")\nend","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html#Expected-Values-of-MPO-Operators","page":"MPS and MPO Examples","title":"Expected Values of MPO Operators","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"When using an MPS to represent a quantum wavefunction psirangle another common operation is computing the expected value langlepsiWpsirangle of an operator W which is represented as a matrix product operator (MPO) tensor network. A key example could be the Hamiltonian defining a quantum system.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Given an MPO W and an MPS psi, you can compute langlepsiWpsirangle by using the function inner as follows:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"ex_W = inner(psi',W,psi)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"which will return a scalar that may be either real or complex, depending on the properties of psi and W.","category":"page"},{"location":"examples/MPSandMPO.html#Computing-Correlation-Functions","page":"MPS and MPO Examples","title":"Computing Correlation Functions","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"In addition to expected values of local operators discussed above, another type of observable that is very important in physics studies are correlation functions of the form","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"C_ij = langlepsi A_i B_j psirangle","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"These can be computed efficiently for an MPS psi in ITensor using the correlation_matrix function:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"C = correlation_matrix(psi,\"A\",\"B\")","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"where \"A\" and \"B\" must be an operator names associated with the physical site type, or site tags, of the sites of the MPS psi. For example, these strings could be \"Sz\", \"S+\", or \"S-\" for spin sites, or \"Cdagup\" and \"Cup\" for electron sites. (For more information about defining such operators yourself, see the section on Extending op Function Definitions.)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"As a concrete example, say we have an MPS psi for a system of spins and want to compute the correlator langlepsiS^z_i S^z_jpsirangle. We can compute this as:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"zzcorr = correlation_matrix(psi,\"Sz\",\"Sz\")","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"See the correlation_matrix docs for more details about additional arguments you can pass to this function.","category":"page"},{"location":"examples/MPSandMPO.html#Applying-a-Single-site-Operator-to-an-MPS","page":"MPS and MPO Examples","title":"Applying a Single-site Operator to an MPS","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"In many applications one needs to modify a matrix product state (MPS) by multiplying it with an operator that acts only on a single site. This is actually a very straightforward operation and this formula shows you how to do it in ITensor.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Say we have an operator G^s_3_s_3 which acts non-trivially on site 3 of our MPS psi as in the following diagram:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"To carry out this operation, contract the operator G with the MPS tensor for site 3, removing the prime from the s_3 index afterward:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"newA = G * psi[3]\nnewA = noprime(newA)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Finally, put the new tensor back into MPS psi to update its third MPS tensor:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"psi[3] = newA","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Afterward, we can visualize the modified MPS as:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"As a technical note, if you are working in a context where gauge or orthogonality properties of the MPS are important, such as in time evolution using two-site gates, then you may want to call psi = orthogonalize(psi, 3) before modifying the tensor at site 3, which will ensure that the MPS remains in a well-defined orthogonal gauge centered on site 3. Modifying a tensor which is left- or right-orthogonal (i.e. not the \"center\" tensor of the gauge) will destroy the gauge condition and require extra operations to restore it. (Calling orthogonalize method will automatically fix this but will have to do extra work to do so.)","category":"page"},{"location":"examples/MPSandMPO.html#Applying-a-Two-site-Operator-to-an-MPS","page":"MPS and MPO Examples","title":"Applying a Two-site Operator to an MPS","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"A very common operation with matrix product states (MPS) is multiplication by a two-site operator or \"gate\" which modifies the MPS. This procedure can be carried out in an efficient, controlled way which is adaptive in the MPS bond dimension.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Say we have an operator G^s_3 s_4_s_3 s_4 which is our gate and which acts on physical sites 3 and 4 of our MPS psi, as in the following diagram:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"To apply this gate in a controlled manner, first 'gauge' the MPS psi such that either site 3 or 4 is the orthogonality center. Here we make site 3 the center:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"psi = orthogonalize(psi, 3)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"The other MPS tensors are now either left-orthogonal or right-orthogonal and can be left out of further steps without producing incorrect results.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Next, contract the gate tensor G with the MPS tensors for sites 3 and 4","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"wf = (psi[3] * psi[4]) * G\nwf = noprime(wf)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Finally, use the singular value decomposition (SVD) to factorize the resulting tensor, multiplying the singular values into either U or V. Assign these two tensors back into the MPS to update it.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"(Image: )","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"inds3 = uniqueinds(psi[3],psi[4])\nU,S,V = svd(wf,inds3,cutoff=1E-8)\npsi[3] = U\npsi[4] = S*V","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"The call to uniqueinds(psi[3]) analyzes the indices of psi[3] and psi[4] and finds any which are unique to just psi[3], saving this collection of indices as inds3. Passing this collection of indices to the svd function tells it to treat any indices that are unique to psi[3] as the indices which should go onto the U tensor afterward. We also set a truncation error cutoff of 1E-8 in the call to svd to truncate the smallest singular values and control the size of the resulting MPS. Other cutoff values can be used, depending on the desired accuracy, as well as limits on the maximum bond dimension (maxdim keyword argument).","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Complete code example","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"using ITensors, ITensorMPS\n\npsi = orthogonalize(psi, 3)\n\nwf = (psi[3] * psi[4]) * G\nwf = noprime(wf)\n\ninds3 = uniqueinds(psi[3], psi[4])\nU, S, V = svd(wf, inds3; cutoff=1E-8)\npsi[3] = U\npsi[4] = S * V","category":"page"},{"location":"examples/MPSandMPO.html#Computing-the-Entanglement-Entropy-of-an-MPS","page":"MPS and MPO Examples","title":"Computing the Entanglement Entropy of an MPS","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"A key advantage of using the matrix product state (MPS) format to represent quantum wavefunctions is that it allows one to efficiently compute the entanglement entropy of any left-right bipartition of the system in one dimension, or for a two-dimensional system any \"cut\" along the MPS path.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Say that we have obtained an MPS psi of length N and we wish to compute the entanglement entropy of a bipartition of the system into a region \"A\" which consists of sites 1,2,...,b and a region B consisting of sites b+1,b+2,...,N.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Then the following code formula can be used to accomplish this task:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"psi = orthogonalize(psi, b)\nU,S,V = svd(psi[b], (linkinds(psi, b-1)..., siteinds(psi, b)...))\nSvN = 0.0\nfor n=1:dim(S, 1)\n  p = S[n,n]^2\n  SvN -= p * log(p)\nend","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"As a brief explanation of the code above, the call to psi = orthogonalize(psi, b) shifts the orthogonality center to site b of the MPS.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"The call to the svd routine says to treat the link (virtual or bond) Index connecting the b'th MPS tensor psi[b] and the b'th physical Index as \"row\" indices for the purposes of the SVD (these indices will end up on U, along with the Index connecting U to S).","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"The code in the for loop iterates over the diagonal elements of the S tensor (which are the singular values from the SVD), computes their squares to obtain the probabilities of observing the various states in the Schmidt basis (i.e. eigenvectors of the left-right bipartition reduced density matrices), and puts them into the von Neumann entanglement entropy formula S_textvN = - sum_n p_n logp_n.","category":"page"},{"location":"examples/MPSandMPO.html#Sampling-from-an-MPS","page":"MPS and MPO Examples","title":"Sampling from an MPS","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"A matrix product state (MPS) can be viewed as defining a probability distribution through the Born rule, as is the case when the MPS represents a quantum wavefunction. To sample from the distribution defined by an MPS, you can use the function sample provided in ITensor. For an MPS psi call to sample(psi) returns a random sample from the distribution defined by psi. (Note that each sample is drawn anew and not from a Markov chain seeded by a previous sample; this is possible because the algorithm for sampling MPS is a `perfect' sampling algorithm with no autocorrelation.)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"In more detail, say we have a set of N site indices s and define a random MPS with these sites:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"using ITensors, ITensorMPS\n\nN = 10 # number of sites\nd = 3  # dimension of each site\nchi = 16 # bond dimension of the MPS\ns = siteinds(d,N)\npsi = random_mps(s;linkdims=chi)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"We can now draw some samples from this MPS as","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"v1 = sample(psi)\nv2 = sample(psi)\nv3 = sample(psi)\nprintln(v1)\nprintln(v2)\nprintln(v3)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"The integers in each of the samples represent settings of each of the MPS indices in the \"computational basis\".","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"For reasons of efficiency, the sample function requires the MPS to be in orthogonal form, orthogonalized to the first site. If it is not already in this form, it can be brought into orthogonal form by calling psi = orthogonalize(psi, 1).","category":"page"},{"location":"examples/MPSandMPO.html#Write-and-Read-an-MPS-or-MPO-to-Disk-with-HDF5","page":"MPS and MPO Examples","title":"Write and Read an MPS or MPO to Disk with HDF5","text":"","category":"section"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"info: Info\nMake sure to install the HDF5 package to use this feature. (Run julia> ] add HDF5 in the Julia REPL console.)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Writing an MPS to an HDF5 File","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Let's say you have an MPS psi which you have made or obtained from a calculation. To write it to an HDF5 file named \"myfile.h5\" you can use the following pattern:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"using HDF5\nf = h5open(\"myfile.h5\",\"w\")\nwrite(f,\"psi\",psi)\nclose(f)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Above, the string \"psi\" can actually be any string you want such as \"MPS psi\" or \"Result MPS\" and doesn't have to have the same name as the reference psi. Closing the file f is optional and you can also write other objects to the same file before closing it.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Reading an MPS from an HDF5 File","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Say you have an HDF5 file \"myfile.h5\" which contains an MPS stored as a dataset with the name \"psi\". (Which would be the situation if you wrote it as in the example above.) To read this ITensor back from the HDF5 file, use the following pattern:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"using HDF5\nf = h5open(\"myfile.h5\",\"r\")\npsi = read(f,\"psi\",MPS)\nclose(f)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Many functions which involve MPS, such as the dmrg function or the OpSum system require that you use an array of site indices which match the MPS. So when reading in an MPS from disk, do not construct a new array of site indices. Instead, you can obtain them like this: sites = siteinds(psi).","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"So for example, to create an MPO from an OpSum which has the same site indices as your MPS psi, do the following:","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"using ITensors, ITensorMPS\n\nos = OpSum()\n# Then put operators into os...\n\nsites = siteinds(psi) # Get site indices from your MPS\nH = MPO(os,sites)\n\n# Compute <psi|H|psi>\nenergy_psi = inner(psi',H,psi)","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Note the MPS argument to the read function, which tells Julia which read function to call and how to interpret the data stored in the HDF5 dataset named \"psi\". In the future we might lift the requirement of providing the type and have it be detected automatically from the data stored in the file.","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"Writing and Reading MPOs","category":"page"},{"location":"examples/MPSandMPO.html","page":"MPS and MPO Examples","title":"MPS and MPO Examples","text":"To write or read MPOs to or from HDF5 files, just follow the examples above but use the type MPO when reading an MPO from the file instead of the type MPS.","category":"page"},{"location":"OpSum.html#OpSum","page":"OpSum","title":"OpSum","text":"","category":"section"},{"location":"OpSum.html#Description","page":"OpSum","title":"Description","text":"","category":"section"},{"location":"OpSum.html","page":"OpSum","title":"OpSum","text":"OpSum","category":"page"},{"location":"OpSum.html#ITensors.Ops.OpSum","page":"OpSum","title":"ITensors.Ops.OpSum","text":"An OpSum represents a sum of operator terms.\n\nOften it is used to create matrix product operator (MPO) approximation of the sum of the terms in the OpSum oject. Each term is a product of local operators specified by names such as \"Sz\" or \"N\", times an optional coefficient which can be real or complex.\n\nWhich local operator names are available is determined by the function op associated with the TagType defined by special Index tags, such as \"S=1/2\", \"S=1\", \"Fermion\", and \"Electron\".\n\n\n\n\n\n","category":"type"},{"location":"OpSum.html#Methods","page":"OpSum","title":"Methods","text":"","category":"section"},{"location":"OpSum.html","page":"OpSum","title":"OpSum","text":"add!\nMPO(::OpSum,::Vector{<:Index})","category":"page"},{"location":"OpSum.html#ITensorMPS.add!","page":"OpSum","title":"ITensorMPS.add!","text":"add!(opsum::OpSum,\n     op1::String, i1::Int)\n\nadd!(opsum::OpSum,\n     coef::Number,\n     op1::String, i1::Int)\n\nadd!(opsum::OpSum,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\nadd!(opsum::OpSum,\n     coef::Number,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\n+(opsum:OpSum, term::Tuple)\n\nAdd a single- or multi-site operator term to the OpSum opsum. Each operator is specified by a name (String) and a site number (Int). The second version accepts a real or complex coefficient.\n\nThe + operator version of this function accepts a tuple with entries either (String,Int,String,Int,...) or (Number,String,Int,String,Int,...) where these tuple values are the same as valid inputs to the add! function. For inputting a very large number of terms (tuples) to an OpSum, consider using the broadcasted operator .+= which avoids reallocating the OpSum after each addition.\n\nExamples\n\nopsum = OpSum()\n\nadd!(opsum,\"Sz\",2,\"Sz\",3)\n\nopsum += (\"Sz\",3,\"Sz\",4)\n\nopsum += (0.5,\"S+\",4,\"S-\",5)\n\nopsum .+= (0.5,\"S+\",5,\"S-\",6)\n\n\n\n\n\n","category":"function"},{"location":"OpSum.html#ITensorMPS.MPO-Tuple{ITensors.LazyApply.Applied{typeof(sum), Tuple{Array{ITensors.LazyApply.Applied{typeof(*), Tuple{C, Prod{Op}}, @NamedTuple{}}, 1}}, @NamedTuple{}} where C, Vector{<:Index}}","page":"OpSum","title":"ITensorMPS.MPO","text":"MPO(os::OpSum, sites::Vector{<:Index}; splitblocks=true, kwargs...)\nMPO(eltype::Type{<:Number}, os::OpSum, sites::Vector{<:Index}; splitblocks=true, kwargs...)\n\nConvert an OpSum object os to an MPO, with indices given by sites. The resulting MPO will have the indices sites[1], sites[1]', sites[2], sites[2]' etc. The conversion is done by an algorithm that compresses the MPO resulting from adding the OpSum terms together, often achieving the minimum possible bond dimension.\n\nOptionally specify the desired element type of the output MPO by passing the type as the first argument.\n\nThe keyword argument splitblocks controls the sparsity of the resulting MPO. With the default splitblocks=true, the link indices of the MPO are split into blocks of dimension 1, potentially making the MPO more sparse.\n\nWith the splitblocks=false, the blocks of the link dimensions are packed as much as possible according to common quantum numbers, making larger blocks. Before ITensors 0.3.19, this was the default output, but we have found that in general MPOs output with splitblocks=true lead to better performance in algorithms like DMRG.\n\nExamples\n\nos = OpSum()\nos += \"Sz\",1,\"Sz\",2\nos += \"Sz\",2,\"Sz\",3\nos += \"Sz\",3,\"Sz\",4\n\nsites = siteinds(\"S=1/2\",4)\nH = MPO(os,sites)\nH = MPO(Float32,os,sites)\nH = MPO(os,sites; splitblocks=false)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPS-and-MPO","page":"MPS and MPO","title":"MPS and MPO","text":"","category":"section"},{"location":"MPSandMPO.html#Types","page":"MPS and MPO","title":"Types","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"MPS\nMPO","category":"page"},{"location":"MPSandMPO.html#ITensorMPS.MPS","page":"MPS and MPO","title":"ITensorMPS.MPS","text":"MPS\n\nA finite size matrix product state type. Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#ITensorMPS.MPO","page":"MPS and MPO","title":"ITensorMPS.MPO","text":"MPO\n\nA finite size matrix product operator type. Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#MPS-Constructors","page":"MPS and MPO","title":"MPS Constructors","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"MPS(::Int)\nMPS(::Type{<:Number}, ::Vector{<:Index})\nrandom_mps(sites::Vector{<:Index})\nrandom_mps(::Type{<:Number}, sites::Vector{<:Index})\nrandom_mps(::Vector{<:Index}, ::Any)\nMPS(::Vector{<:Index}, ::Any)\nMPS(::Type{<:Number}, ::Vector{<:Index}, ::Any)\nMPS(::Vector{<:Pair{<:Index}})\nMPS(::Type{<:Number}, ::Vector{<:Pair{<:Index}})","category":"page"},{"location":"MPSandMPO.html#ITensorMPS.MPS-Tuple{Int64}","page":"MPS and MPO","title":"ITensorMPS.MPS","text":"MPS(N::Int)\n\nConstruct an MPS with N sites with default constructed ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.MPS-Tuple{Type{<:Number}, Vector{<:Index}}","page":"MPS and MPO","title":"ITensorMPS.MPS","text":"MPS([::Type{ElT} = Float64, ]sites; linkdims=1)\n\nConstruct an MPS filled with Empty ITensors of type ElT from a collection of indices.\n\nOptionally specify the link dimension with the keyword argument linkdims, which by default is 1.\n\nIn the future we may generalize linkdims to allow specifying each individual link dimension as a vector, and additionally allow specifying quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.random_mps-Tuple{Vector{<:Index}}","page":"MPS and MPO","title":"ITensorMPS.random_mps","text":"random_mps(sites::Vector{<:Index}; linkdims=1)\nrandom_mps(eltype::Type{<:Number}, sites::Vector{<:Index}; linkdims=1)\n\nConstruct a random MPS with link dimension linkdims which by default has element type Float64.\n\nlinkdims can also accept a Vector{Int} with length(linkdims) == length(sites) - 1 for constructing an MPS with non-uniform bond dimension.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.random_mps-Tuple{Type{<:Number}, Vector{<:Index}}","page":"MPS and MPO","title":"ITensorMPS.random_mps","text":"random_mps(eltype::Type{<:Number}, sites::Vector{<:Index}; linkdims=1)\n\nConstruct a random MPS with link dimension linkdims of type eltype.\n\nlinkdims can also accept a Vector{Int} with length(linkdims) == length(sites) - 1 for constructing an MPS with non-uniform bond dimension.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.random_mps-Tuple{Vector{<:Index}, Any}","page":"MPS and MPO","title":"ITensorMPS.random_mps","text":"random_mps(sites::Vector{<:Index}, state; linkdims=1)\n\nConstruct a real, random MPS with link dimension linkdims, made by randomizing an initial product state specified by state. This version of random_mps is necessary when creating QN-conserving random MPS (consisting of QNITensors). The initial state array provided determines the total QN of the resulting random MPS.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.MPS-Tuple{Vector{<:Index}, Any}","page":"MPS and MPO","title":"ITensorMPS.MPS","text":"MPS(sites::Vector{<:Index},states)\n\nConstruct a product state MPS having site indices sites, and which corresponds to the initial state given by the array states. The states array may consist of either an array of integers or strings, as recognized by the state function defined for the relevant Index tag type.\n\nExamples\n\nN = 10\nsites = siteinds(\"S=1/2\", N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\npsi = MPS(sites, states)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.MPS-Tuple{Type{<:Number}, Vector{<:Index}, Any}","page":"MPS and MPO","title":"ITensorMPS.MPS","text":"MPS(::Type{T},\n    sites::Vector{<:Index},\n    states::Union{Vector{String},\n                  Vector{Int},\n                  String,\n                  Int})\n\nConstruct a product state MPS of element type T, having site indices sites, and which corresponds to the initial state given by the array states. The input states may be an array of strings or an array of ints recognized by the state function defined for the relevant Index tag type. In addition, a single string or int can be input to create a uniform state.\n\nExamples\n\nN = 10\nsites = siteinds(\"S=1/2\", N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\npsi = MPS(ComplexF64, sites, states)\nphi = MPS(sites, \"Up\")\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.MPS-Tuple{Vector{<:Pair{<:Index}}}","page":"MPS and MPO","title":"ITensorMPS.MPS","text":"MPS(ivals::Vector{<:Pair{<:Index}})\n\nConstruct a product state MPS with element type Float64 and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.MPS-Tuple{Type{<:Number}, Vector{<:Pair{<:Index}}}","page":"MPS and MPO","title":"ITensorMPS.MPS","text":"MPS(::Type{T<:Number}, ivals::Vector{<:Pair{<:Index}})\n\nConstruct a product state MPS with element type T and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPO-Constructors","page":"MPS and MPO","title":"MPO Constructors","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"MPO(::Int)\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::Vector{String})\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::String)","category":"page"},{"location":"MPSandMPO.html#ITensorMPS.MPO-Tuple{Int64}","page":"MPS and MPO","title":"ITensorMPS.MPO","text":"MPO(N::Int)\n\nMake an MPO of length N filled with default ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.MPO-Tuple{Type{<:Number}, Vector{<:Index}, Vector{String}}","page":"MPS and MPO","title":"ITensorMPS.MPO","text":"MPO([::Type{ElT} = Float64}, ]sites, ops::Vector{String})\n\nMake an MPO with pairs of sites s[i] and s[i]' and operators ops on each site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.MPO-Tuple{Type{<:Number}, Vector{<:Index}, String}","page":"MPS and MPO","title":"ITensorMPS.MPO","text":"MPO([::Type{ElT} = Float64, ]sites, op::String)\n\nMake an MPO with pairs of sites s[i] and s[i]' and operator op on every site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Copying-behavior","page":"MPS and MPO","title":"Copying behavior","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"copy(::ITensorMPS.AbstractMPS)\ndeepcopy(::ITensorMPS.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#Base.copy-Tuple{AbstractMPS}","page":"MPS and MPO","title":"Base.copy","text":"copy(::MPS)\ncopy(::MPO)\n\nMake a shallow copy of an MPS or MPO. By shallow copy, it means that a new MPS/MPO is returned, but the data of the tensors are still shared between the returned MPS/MPO and the original MPS/MPO.\n\nTherefore, replacing an entire tensor of the returned MPS/MPO will not modify the input MPS/MPO, but modifying the data of the returned MPS/MPO will modify the input MPS/MPO.\n\nUse deepcopy for an alternative that copies the ITensors as well.\n\nExamples\n\njulia> using ITensors, ITensorMPS\n\njulia> s = siteinds(\"S=1/2\", 3);\n\njulia> M1 = random_mps(s; linkdims=3);\n\njulia> norm(M1)\n0.9999999999999999\n\njulia> M2 = copy(M1);\n\njulia> M2[1] *= 2;\n\njulia> norm(M1)\n0.9999999999999999\n\njulia> norm(M2)\n1.9999999999999998\n\njulia> M3 = copy(M1);\n\njulia> M3[1] .*= 3; # Modifies the tensor data\n\njulia> norm(M1)\n3.0000000000000004\n\njulia> norm(M3)\n3.0000000000000004\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.deepcopy-Tuple{AbstractMPS}","page":"MPS and MPO","title":"Base.deepcopy","text":"deepcopy(::MPS)\ndeepcopy(::MPO)\n\nMake a deep copy of an MPS or MPO. By deep copy, it means that a new MPS/MPO is returned that doesn't share any data with the input MPS/MPO.\n\nTherefore, modifying the resulting MPS/MPO will note modify the original MPS/MPO.\n\nUse copy for an alternative that performs a shallow copy that avoids copying the ITensor data.\n\nExamples\n\njulia> using ITensors, ITensorMPS\n\njulia> s = siteinds(\"S=1/2\", 3);\n\njulia> M1 = random_mps(s; linkdims=3);\n\njulia> norm(M1)\n1.0\n\njulia> M2 = deepcopy(M1);\n\njulia> M2[1] .*= 2; # Modifies the tensor data\n\njulia> norm(M1)\n1.0\n\njulia> norm(M2)\n2.0\n\njulia> M3 = copy(M1);\n\njulia> M3[1] .*= 3; # Modifies the tensor data\n\njulia> norm(M1)\n3.0\n\njulia> norm(M3)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Properties","page":"MPS and MPO","title":"Properties","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"eltype(::ITensorMPS.AbstractMPS)\nflux(::ITensorMPS.AbstractMPS)\nhasqns(::ITensorMPS.AbstractMPS)\nlength(::ITensorMPS.AbstractMPS)\nmaxlinkdim(::ITensorMPS.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#Base.eltype-Tuple{AbstractMPS}","page":"MPS and MPO","title":"Base.eltype","text":"eltype(m::MPS)\neltype(m::MPO)\n\nThe element type of the MPS/MPO. Always returns ITensor.\n\nFor the element type of the ITensors of the MPS/MPO, use promote_itensor_eltype.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.flux-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.flux","text":"flux(M::MPS)\n\nflux(M::MPO)\n\ntotalqn(M::MPS)\n\ntotalqn(M::MPO)\n\nFor an MPS or MPO which conserves quantum numbers, compute the total QN flux. For a tensor network such as an MPS or MPO, the flux is the sum of fluxes of each of the tensors in the network. The name totalqn is an alias for flux.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.hasqns-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.hasqns","text":"hasqns(M::MPS)\n\nhasqns(M::MPO)\n\nReturn true if the MPS or MPO has tensors which carry quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.length-Tuple{AbstractMPS}","page":"MPS and MPO","title":"Base.length","text":"length(::MPS/MPO)\n\nThe number of sites of an MPS/MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.maxlinkdim-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensorMPS.maxlinkdim","text":"maxlinkdim(M::MPS)\nmaxlinkdim(M::MPO)\n\nGet the maximum link dimension of the MPS or MPO.\n\nThe minimum this will return is 1, even if there are no link indices.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Obtaining-and-finding-indices","page":"MPS and MPO","title":"Obtaining and finding indices","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"siteinds(::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS, ::Int)\nsiteinds(::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS, ::Int)\nfindsite\nfindsites\nfirstsiteinds\nlinkind(::ITensorMPS.AbstractMPS,::Int)\nsiteind(::MPS, ::Int)\nsiteind(::typeof(first), ::MPS, ::Int)\nsiteinds(::MPS)\nsiteind(::MPO, ::Int)\nsiteinds(::MPO)\nsiteinds(::ITensorMPS.AbstractMPS, ::Int)","category":"page"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteinds-Tuple{typeof(commoninds), AbstractMPS, AbstractMPS, Int64}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","text":"siteinds(commoninds, A::MPO, B::MPS, j::Integer; kwargs...)\nsiteinds(commonind, A::MPO, B::MPO, j::Integer; kwargs...)\n\nGet the site index (or indices) of  the jth MPO tensor of A that is shared with MPS/MPO B.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteinds-Tuple{typeof(uniqueinds), AbstractMPS, AbstractMPS, Int64}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","text":"siteinds(uniqueinds, A::MPO, B::MPS, j::Integer; kwargs...)\nsiteinds(uniqueind, A::MPO, B::MPS, j::Integer; kwargs...)\n\nGet the site index (or indices) of MPO A that is unique to A (not shared with MPS/MPO B).\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.findsite","page":"MPS and MPO","title":"ITensorMPS.findsite","text":"findsite(M::Union{MPS, MPO}, is)\n\nReturn the first site of the MPS or MPO that has at least one Index in common with the Index or collection of indices is.\n\nTo find all sites with common indices with is, use the findsites function.\n\nExamples\n\ns = siteinds(\"S=1/2\", 5)\nψ = random_mps(s)\nfindsite(ψ, s[3]) == 3\nfindsite(ψ, (s[3], s[4])) == 3\n\nM = MPO(s)\nfindsite(M, s[4]) == 4\nfindsite(M, s[4]') == 4\nfindsite(M, (s[4]', s[4])) == 4\nfindsite(M, (s[4]', s[3])) == 3\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensorMPS.findsites","page":"MPS and MPO","title":"ITensorMPS.findsites","text":"findsites(M::Union{MPS, MPO}, is)\n\nReturn the sites of the MPS or MPO that have indices in common with the collection of site indices is.\n\nExamples\n\ns = siteinds(\"S=1/2\", 5)\nψ = random_mps(s)\nfindsites(ψ, s[3]) == [3]\nfindsites(ψ, (s[4], s[1])) == [1, 4]\n\nM = MPO(s)\nfindsites(M, s[4]) == [4]\nfindsites(M, s[4]') == [4]\nfindsites(M, (s[4]', s[4])) == [4]\nfindsites(M, (s[4]', s[3])) == [3, 4]\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensorMPS.firstsiteinds","page":"MPS and MPO","title":"ITensorMPS.firstsiteinds","text":"firstsiteinds(M::MPO; kwargs...)\n\nGet a Vector of the first site Index found on each site of M.\n\nBy default, it finds the first site Index with prime level 0.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensorMPS.linkind-Tuple{AbstractMPS, Int64}","page":"MPS and MPO","title":"ITensorMPS.linkind","text":"linkind(M::MPS, j::Integer)\nlinkind(M::MPO, j::Integer)\n\nGet the link or bond Index connecting the MPS or MPO tensor on site j to site j+1.\n\nIf there is no link Index, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteind-Tuple{MPS, Int64}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteind","text":"siteind(M::MPS, j::Int; kwargs...)\n\nGet the first site Index of the MPS. Return nothing if none is found.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteind-Tuple{typeof(first), MPS, Int64}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteind","text":"siteind(::typeof(first), M::Union{MPS,MPO}, j::Integer; kwargs...)\n\nReturn the first site Index found on the MPS or MPO (the first Index unique to the jth MPS/MPO tensor).\n\nYou can choose different filters, like prime level and tags, with the kwargs.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteinds-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","text":"siteinds(M::MPS)\nsiteinds(::typeof(first), M::MPS)\n\nGet a vector of the first site Index found on each tensor of the MPS.\n\nsiteinds(::typeof(only), M::MPS)\n\nGet a vector of the only site Index found on each tensor of the MPS. Errors if more than one is found.\n\nsiteinds(::typeof(all), M::MPS)\n\nGet a vector of the all site Indices found on each tensor of the MPS. Returns a Vector of IndexSets.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteind-Tuple{MPO, Int64}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteind","text":"siteind(M::MPO, j::Int; plev = 0, kwargs...)\n\nGet the first site Index of the MPO found, by default with prime level 0.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteinds-Tuple{MPO}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","text":"siteinds(M::MPO; kwargs...)\n\nGet a Vector of IndexSets of all the site indices of M.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.SiteTypes.siteinds-Tuple{AbstractMPS, Int64}","page":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","text":"siteinds(M::Union{MPS, MPO}}, j::Integer; kwargs...)\n\nReturn the site Indices found of the MPO or MPO at the site j as an IndexSet.\n\nOptionally filter prime tags and prime levels with keyword arguments like plev and tags.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Priming-and-tagging","page":"MPS and MPO","title":"Priming and tagging","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"prime(::ITensorMPS.AbstractMPS)\nprime(::typeof(siteinds), ::ITensorMPS.AbstractMPS)\nprime(::typeof(linkinds), ::ITensorMPS.AbstractMPS)\nprime(::typeof(siteinds), ::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\nprime(::typeof(siteinds), ::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\n\nswapprime(::ITensorMPS.AbstractMPS, args...; kwargs...)\n\nsetprime(::ITensorMPS.AbstractMPS)\nsetprime(::typeof(siteinds), ::ITensorMPS.AbstractMPS)\nsetprime(::typeof(linkinds), ::ITensorMPS.AbstractMPS)\nsetprime(::typeof(siteinds), ::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\nsetprime(::typeof(siteinds), ::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\n\nnoprime(::ITensorMPS.AbstractMPS)\nnoprime(::typeof(siteinds), ::ITensorMPS.AbstractMPS)\nnoprime(::typeof(linkinds), ::ITensorMPS.AbstractMPS)\nnoprime(::typeof(siteinds), ::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\nnoprime(::typeof(siteinds), ::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\n\naddtags(::ITensorMPS.AbstractMPS)\naddtags(::typeof(siteinds), ::ITensorMPS.AbstractMPS)\naddtags(::typeof(linkinds), ::ITensorMPS.AbstractMPS)\naddtags(::typeof(siteinds), ::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\naddtags(::typeof(siteinds), ::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\n\nremovetags(::ITensorMPS.AbstractMPS)\nremovetags(::typeof(siteinds), ::ITensorMPS.AbstractMPS)\nremovetags(::typeof(linkinds), ::ITensorMPS.AbstractMPS)\nremovetags(::typeof(siteinds), ::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\nremovetags(::typeof(siteinds), ::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\n\nreplacetags(::ITensorMPS.AbstractMPS)\nreplacetags(::typeof(siteinds), ::ITensorMPS.AbstractMPS)\nreplacetags(::typeof(linkinds), ::ITensorMPS.AbstractMPS)\nreplacetags(::typeof(siteinds), ::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\nreplacetags(::typeof(siteinds), ::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\n\nsettags(::ITensorMPS.AbstractMPS)\nsettags(::typeof(siteinds), ::ITensorMPS.AbstractMPS)\nsettags(::typeof(linkinds), ::ITensorMPS.AbstractMPS)\nsettags(::typeof(siteinds), ::typeof(commoninds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)\nsettags(::typeof(siteinds), ::typeof(uniqueinds), ::ITensorMPS.AbstractMPS, ::ITensorMPS.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime[!](M::MPS, args...; kwargs...)\nprime[!](M::MPO, args...; kwargs...)\n\nApply prime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{typeof(siteinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime[!](siteinds, M::MPS, args...; kwargs...)\nprime[!](siteinds, M::MPO, args...; kwargs...)\n\nApply prime to all site indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{typeof(linkinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime[!](linkinds, M::MPS, args...; kwargs...)\nprime[!](linkinds, M::MPO, args...; kwargs...)\n\nApply prime to all link indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)\n\nApply prime to the site indices that are shared by M1 and M2.\n\nReturns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)\n\nApply prime to the site indices of M1 that are not shared with M2. Returns new MPSs/MPOs.\n\nThe ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.swapprime-Tuple{AbstractMPS, Vararg{Any}}","page":"MPS and MPO","title":"ITensors.swapprime","text":"swapprime[!](M::MPS, args...; kwargs...)\nswapprime[!](M::MPO, args...; kwargs...)\n\nApply swapprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime[!](M::MPS, args...; kwargs...)\nsetprime[!](M::MPO, args...; kwargs...)\n\nApply setprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{typeof(siteinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime[!](siteinds, M::MPS, args...; kwargs...)\nsetprime[!](siteinds, M::MPO, args...; kwargs...)\n\nApply setprime to all site indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{typeof(linkinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime[!](linkinds, M::MPS, args...; kwargs...)\nsetprime[!](linkinds, M::MPO, args...; kwargs...)\n\nApply setprime to all link indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nsetprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)\n\nApply setprime to the site indices that are shared by M1 and M2.\n\nReturns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)\n\nApply setprime to the site indices of M1 that are not shared with M2. Returns new MPSs/MPOs.\n\nThe ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime[!](M::MPS, args...; kwargs...)\nnoprime[!](M::MPO, args...; kwargs...)\n\nApply noprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{typeof(siteinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime[!](siteinds, M::MPS, args...; kwargs...)\nnoprime[!](siteinds, M::MPO, args...; kwargs...)\n\nApply noprime to all site indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{typeof(linkinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime[!](linkinds, M::MPS, args...; kwargs...)\nnoprime[!](linkinds, M::MPO, args...; kwargs...)\n\nApply noprime to all link indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nnoprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)\n\nApply noprime to the site indices that are shared by M1 and M2.\n\nReturns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)\n\nApply noprime to the site indices of M1 that are not shared with M2. Returns new MPSs/MPOs.\n\nThe ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.addtags-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.addtags","text":"addtags[!](M::MPS, args...; kwargs...)\naddtags[!](M::MPO, args...; kwargs...)\n\nApply addtags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.addtags-Tuple{typeof(siteinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.addtags","text":"addtags[!](siteinds, M::MPS, args...; kwargs...)\naddtags[!](siteinds, M::MPO, args...; kwargs...)\n\nApply addtags to all site indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.addtags-Tuple{typeof(linkinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.addtags","text":"addtags[!](linkinds, M::MPS, args...; kwargs...)\naddtags[!](linkinds, M::MPO, args...; kwargs...)\n\nApply addtags to all link indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.addtags","text":"addtags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\naddtags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)\n\nApply addtags to the site indices that are shared by M1 and M2.\n\nReturns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.addtags","text":"addtags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)\n\nApply addtags to the site indices of M1 that are not shared with M2. Returns new MPSs/MPOs.\n\nThe ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.removetags-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.removetags","text":"removetags[!](M::MPS, args...; kwargs...)\nremovetags[!](M::MPO, args...; kwargs...)\n\nApply removetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.removetags-Tuple{typeof(siteinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.removetags","text":"removetags[!](siteinds, M::MPS, args...; kwargs...)\nremovetags[!](siteinds, M::MPO, args...; kwargs...)\n\nApply removetags to all site indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.removetags-Tuple{typeof(linkinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.removetags","text":"removetags[!](linkinds, M::MPS, args...; kwargs...)\nremovetags[!](linkinds, M::MPO, args...; kwargs...)\n\nApply removetags to all link indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.removetags","text":"removetags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nremovetags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)\n\nApply removetags to the site indices that are shared by M1 and M2.\n\nReturns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.removetags","text":"removetags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)\n\nApply removetags to the site indices of M1 that are not shared with M2. Returns new MPSs/MPOs.\n\nThe ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.replacetags-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.replacetags","text":"replacetags[!](M::MPS, args...; kwargs...)\nreplacetags[!](M::MPO, args...; kwargs...)\n\nApply replacetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.replacetags","text":"replacetags[!](siteinds, M::MPS, args...; kwargs...)\nreplacetags[!](siteinds, M::MPO, args...; kwargs...)\n\nApply replacetags to all site indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.replacetags-Tuple{typeof(linkinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.replacetags","text":"replacetags[!](linkinds, M::MPS, args...; kwargs...)\nreplacetags[!](linkinds, M::MPO, args...; kwargs...)\n\nApply replacetags to all link indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.replacetags","text":"replacetags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nreplacetags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)\n\nApply replacetags to the site indices that are shared by M1 and M2.\n\nReturns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.TagSets.replacetags","text":"replacetags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)\n\nApply replacetags to the site indices of M1 that are not shared with M2. Returns new MPSs/MPOs.\n\nThe ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags[!](M::MPS, args...; kwargs...)\nsettags[!](M::MPO, args...; kwargs...)\n\nApply settags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{typeof(siteinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags[!](siteinds, M::MPS, args...; kwargs...)\nsettags[!](siteinds, M::MPO, args...; kwargs...)\n\nApply settags to all site indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{typeof(linkinds), AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags[!](linkinds, M::MPS, args...; kwargs...)\nsettags[!](linkinds, M::MPO, args...; kwargs...)\n\nApply settags to all link indices of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nsettags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)\n\nApply settags to the site indices that are shared by M1 and M2.\n\nReturns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)\n\nApply settags to the site indices of M1 that are not shared with M2. Returns new MPSs/MPOs.\n\nThe ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Operations","page":"MPS and MPO","title":"Operations","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"expect(::MPS, ::Any)\ncorrelation_matrix(::MPS, ::AbstractString, ::AbstractString)\ndag(::ITensorMPS.AbstractMPS)\ndense(::ITensorMPS.AbstractMPS)\nmovesite(::ITensorMPS.AbstractMPS, ::Pair{Int, Int};orthocenter::Int,kwargs...)\northogonalize!\nreplacebond!(::MPS, ::Int, ::ITensor)\nsample(::MPS)\nsample!(::MPS)\nsample(::MPO)\nswapbondsites(::ITensorMPS.AbstractMPS, ::Int; kwargs...)\ntruncate!","category":"page"},{"location":"MPSandMPO.html#ITensorMPS.expect-Tuple{MPS, Any}","page":"MPS and MPO","title":"ITensorMPS.expect","text":"expect(psi::MPS, op::AbstractString...; kwargs...)\nexpect(psi::MPS, op::Matrix{<:Number}...; kwargs...)\nexpect(psi::MPS, ops; kwargs...)\n\nGiven an MPS psi and a single operator name, returns a vector of the expected value of the operator on each site of the MPS.\n\nIf multiple operator names are provided, returns a tuple of expectation value vectors.\n\nIf a container of operator names is provided, returns the same type of container with names replaced by vectors of expectation values.\n\nOptional Keyword Arguments\n\nsites = 1:length(psi): compute expected values only for sites in the given range\n\nExamples\n\nN = 10\n\ns = siteinds(\"S=1/2\", N)\npsi = random_mps(s; linkdims=8)\nZ = expect(psi, \"Sz\") # compute for all sites\nZ = expect(psi, \"Sz\"; sites=2:4) # compute for sites 2,3,4\nZ3 = expect(psi, \"Sz\"; sites=3)  # compute for site 3 only (output will be a scalar)\nXZ = expect(psi, [\"Sx\", \"Sz\"]) # compute Sx and Sz for all sites\nZ = expect(psi, [1/2 0; 0 -1/2]) # same as expect(psi,\"Sz\")\n\ns = siteinds(\"Electron\", N)\npsi = random_mps(s; linkdims=8)\ndens = expect(psi, \"Ntot\")\nupdens, dndens = expect(psi, \"Nup\", \"Ndn\") # pass more than one operator\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.correlation_matrix-Tuple{MPS, AbstractString, AbstractString}","page":"MPS and MPO","title":"ITensorMPS.correlation_matrix","text":"correlation_matrix(psi::MPS,\n                   Op1::AbstractString,\n                   Op2::AbstractString;\n                   kwargs...)\n\ncorrelation_matrix(psi::MPS,\n                   Op1::Matrix{<:Number},\n                   Op2::Matrix{<:Number};\n                   kwargs...)\n\nGiven an MPS psi and two strings denoting operators (as recognized by the op function), computes the two-point correlation function matrix C[i,j] = <psi| Op1i Op2j |psi> using efficient MPS techniques. Returns the matrix C.\n\nOptional Keyword Arguments\n\nsites = 1:length(psi): compute correlations only  for sites in the given range\nishermitian = false : if false, force independent calculations of the  matrix elements above and below the diagonal, while if true assume they are complex conjugates.\n\nFor a correlation matrix of size NxN and an MPS of typical bond dimension m, the scaling of this algorithm is N^2*m^3.\n\nExamples\n\nN = 30\nm = 4\n\ns = siteinds(\"S=1/2\", N)\npsi = random_mps(s; linkdims=m)\nCzz = correlation_matrix(psi, \"Sz\", \"Sz\")\nCzz = correlation_matrix(psi, [1/2 0; 0 -1/2], [1/2 0; 0 -1/2]) # same as above\n\ns = siteinds(\"Electron\", N; conserve_qns=true)\npsi = random_mps(s, n -> isodd(n) ? \"Up\" : \"Dn\"; linkdims=m)\nCuu = correlation_matrix(psi, \"Cdagup\", \"Cup\"; sites=2:8)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.dag-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensors.dag","text":"dag[!](M::MPS, args...; kwargs...)\ndag[!](M::MPO, args...; kwargs...)\n\nApply dag to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#NDTensors.dense-Tuple{AbstractMPS}","page":"MPS and MPO","title":"NDTensors.dense","text":"dense(::MPS/MPO)\n\nGiven an MPS (or MPO), return a new MPS (or MPO) having called dense on each ITensor to convert each tensor to use dense storage and remove any QN or other sparse structure information, if it is not dense already.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.movesite-Tuple{AbstractMPS, Pair{Int64, Int64}}","page":"MPS and MPO","title":"ITensorMPS.movesite","text":"movesite(::Union{MPS, MPO}, n1n2::Pair{Int, Int})\n\nCreate a new MPS/MPO where the site at n1 is moved to n2, for a pair n1n2 = n1 => n2.\n\nThis is done with a series a pairwise swaps, and can introduce a lot of entanglement into your state, so use with caution.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.orthogonalize!","page":"MPS and MPO","title":"ITensorMPS.orthogonalize!","text":"orthogonalize!(M::MPS, j::Int; kwargs...)\northogonalize(M::MPS, j::Int; kwargs...)\n\northogonalize!(M::MPO, j::Int; kwargs...)\northogonalize(M::MPO, j::Int; kwargs...)\n\nMove the orthogonality center of the MPS to site j. No observable property of the MPS will be changed, and no truncation of the bond indices is performed. Afterward, tensors 1,2,...,j-1 will be left-orthogonal and tensors j+1,j+2,...,N will be right-orthogonal.\n\nEither modify in-place with orthogonalize! or out-of-place with orthogonalize.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensorMPS.replacebond!-Tuple{MPS, Int64, ITensor}","page":"MPS and MPO","title":"ITensorMPS.replacebond!","text":"replacebond!(M::MPS, b::Int, phi::ITensor; kwargs...)\n\nFactorize the ITensor phi and replace the ITensors b and b+1 of MPS M with the factors. Choose the orthogonality with ortho=\"left\"/\"right\".\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.sample-Tuple{MPS}","page":"MPS and MPO","title":"ITensorMPS.sample","text":"sample(m::MPS)\n\nGiven a normalized MPS m with orthocenter(m)==1, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.sample!-Tuple{MPS}","page":"MPS and MPO","title":"ITensorMPS.sample!","text":"sample!(m::MPS)\n\nGiven a normalized MPS m, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents. If the MPS does not have an orthogonality center, orthogonalize!(m,1) will be called before computing the sample.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.sample-Tuple{MPO}","page":"MPS and MPO","title":"ITensorMPS.sample","text":"sample(M::MPO)\n\nGiven a normalized MPO M, returns a Vector{Int} of length(M) corresponding to one sample of the probability distribution defined by the MPO, treating the MPO as a density matrix.\n\nThe MPO M should have an (approximately) positive spectrum.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.swapbondsites-Tuple{AbstractMPS, Int64}","page":"MPS and MPO","title":"ITensorMPS.swapbondsites","text":"swapbondsites(ψ::Union{MPS, MPO}, b::Integer; kwargs...)\n\nSwap the sites b and b+1.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#NDTensors.truncate!","page":"MPS and MPO","title":"NDTensors.truncate!","text":"truncate!(M::MPS; kwargs...)\ntruncate!(M::MPO; kwargs...)\n\nPerform a truncation of all bonds of an MPS/MPO, using the truncation parameters (cutoff,maxdim, etc.) provided as keyword arguments.\n\nKeyword arguments:\n\nsite_range=1:N - only truncate the MPS bonds between these sites\ncallback=Returns(nothing) - callback function that allows the user to save the per-bond truncation error. The API of callback expects to take two kwargs called link and truncation_error where link is of type Pair{Int64, Int64} and truncation_error is Float64. Consider the following example that illustrates one possible use case.\n\nnbonds = 9\ntruncation_errors = zeros(nbonds)\nfunction callback(; link, truncation_error)\n  bond_no = last(link)\n  truncation_errors[bond_no] = truncation_error\n  return nothing\nend\ntruncate!(ψ; maxdim=5, cutoff=1E-7, callback)\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#Gate-evolution","page":"MPS and MPO","title":"Gate evolution","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"product(::ITensor, ::ITensorMPS.AbstractMPS)\nproduct(::Vector{ITensor}, ::ITensorMPS.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.product-Tuple{ITensor, AbstractMPS}","page":"MPS and MPO","title":"ITensors.product","text":"apply(o::ITensor, ψ::Union{MPS, MPO}, [ns::Vector{Int}]; kwargs...)\nproduct([...])\n\nGet the product of the operator o with the MPS/MPO ψ, where the operator is applied to the sites ns. If ns are not specified, the sites are determined by the common indices between o and the site indices of ψ.\n\nIf ns are non-contiguous, the sites of the MPS are moved to be contiguous. By default, the sites are moved back to their original locations. You can leave them where they are by setting the keyword argument move_sites_back to false.\n\nKeywords\n\ncutoff::Real: singular value truncation cutoff.\nmaxdim::Int: maximum MPS/MPO dimension.\napply_dag::Bool = false: apply the gate and the dagger of the gate (only  relevant for MPO evolution).\nmove_sites_back::Bool = true: after the ITensors are applied to the MPS or  MPO, move the sites of the MPS or MPO back to their original locations.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.product-Tuple{Vector{ITensor}, AbstractMPS}","page":"MPS and MPO","title":"ITensors.product","text":"apply(As::Vector{<:ITensor}, M::Union{MPS, MPO}; kwargs...)\nproduct([...])\n\nApply the ITensors As to the MPS or MPO M, treating them as gates or matrices from pairs of prime or unprimed indices.\n\nKeywords\n\ncutoff::Real: singular value truncation cutoff.\nmaxdim::Int: maximum MPS/MPO dimension.\napply_dag::Bool = false: apply the gate and the dagger of the gate (only relevant for MPO evolution).\nmove_sites_back::Bool = true: after the ITensor is applied to the MPS or  MPO, move the sites of the MPS or MPO back to their original locations.\n\nExamples\n\nApply one-site gates to an MPS:\n\nN = 3\n\nITensors.op(::OpName\"σx\", ::SiteType\"S=1/2\", s::Index) =\n  2*op(\"Sx\", s)\n\nITensors.op(::OpName\"σz\", ::SiteType\"S=1/2\", s::Index) =\n  2*op(\"Sz\", s)\n\n# Make the operator list.\nos = [(\"σx\", n) for n in 1:N]\nappend!(os, [(\"σz\", n) for n in 1:N])\n\n@show os\n\ns = siteinds(\"S=1/2\", N)\ngates = ops(os, s)\n\n# Starting state |↑↑↑⟩\nψ0 = MPS(s, \"↑\")\n\n# Apply the gates.\nψ = apply(gates, ψ0; cutoff = 1e-15)\n\n# Test against exact (full) wavefunction\nprodψ = apply(gates, prod(ψ0))\n@show prod(ψ) ≈ prodψ\n\n# The result is:\n# σz₃ σz₂ σz₁ σx₃ σx₂ σx₁ |↑↑↑⟩ = -|↓↓↓⟩\n@show inner(ψ, MPS(s, \"↓\")) == -1\n\nApply nonlocal two-site gates and one-site gates to an MPS:\n\n# 2-site gate\nfunction ITensors.op(::OpName\"CX\", ::SiteType\"S=1/2\", s1::Index, s2::Index)\n  mat = [1 0 0 0\n         0 1 0 0\n         0 0 0 1\n         0 0 1 0]\n  return itensor(mat, s2', s1', s2, s1)\nend\n\nos = [(\"CX\", 1, 3), (\"σz\", 3)]\n\n@show os\n\n# Start with the state |↓↑↑⟩\nψ0 = MPS(s, n -> n == 1 ? \"↓\" : \"↑\")\n\n# The result is:\n# σz₃ CX₁₃ |↓↑↑⟩ = -|↓↑↓⟩\nψ = apply(ops(os, s), ψ0; cutoff = 1e-15)\n@show inner(ψ, MPS(s, n -> n == 1 || n == 3 ? \"↓\" : \"↑\")) == -1\n\nPerform TEBD-like time evolution:\n\n# Define the nearest neighbor term `S⋅S` for the Heisenberg model\nfunction ITensors.op(::OpName\"expS⋅S\", ::SiteType\"S=1/2\",\n                     s1::Index, s2::Index; τ::Number)\n  O = 0.5 * op(\"S+\", s1) * op(\"S-\", s2) +\n      0.5 * op(\"S-\", s1) * op(\"S+\", s2) +\n            op(\"Sz\", s1) * op(\"Sz\", s2)\n  return exp(τ * O)\nend\n\nτ = -0.1im\nos = [(\"expS⋅S\", (1, 2), (τ = τ,)),\n      (\"expS⋅S\", (2, 3), (τ = τ,))]\nψ0 = MPS(s, n -> n == 1 ? \"↓\" : \"↑\")\nexpτH = ops(os, s)\nψτ = apply(expτH, ψ0)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Algebra-Operations","page":"MPS and MPO","title":"Algebra Operations","text":"","category":"section"},{"location":"MPSandMPO.html","page":"MPS and MPO","title":"MPS and MPO","text":"inner(::MPST, ::MPST) where {MPST <: ITensorMPS.AbstractMPS}\ndot(::MPST, ::MPST) where {MPST <: ITensorMPS.AbstractMPS}\nloginner(::MPST, ::MPST) where {MPST <: ITensorMPS.AbstractMPS}\nlogdot(::MPST, ::MPST) where {MPST <: ITensorMPS.AbstractMPS}\ninner(::MPS, ::MPO, ::MPS)\ndot(::MPS, ::MPO, ::MPS)\ninner(::MPO, ::MPS, ::MPO, ::MPS)\ndot(::MPO, ::MPS, ::MPO, ::MPS)\nnorm(::ITensorMPS.AbstractMPS)\nnormalize(::ITensorMPS.AbstractMPS)\nnormalize!(::ITensorMPS.AbstractMPS)\nlognorm(::ITensorMPS.AbstractMPS)\n+(::ITensorMPS.AbstractMPS...)\ncontract(::MPO, ::MPS)\napply(::MPO, ::MPS)\ncontract(::MPO, ::MPO)\napply(::MPO, ::MPO)\nerror_contract(y::MPS, A::MPO, x::MPS)\nouter(::MPS, ::MPS)\nprojector(::MPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","page":"MPS and MPO","title":"ITensors.inner","text":"inner(A::MPS, B::MPS)\ninner(A::MPO, B::MPO)\n\nCompute the inner product ⟨A|B⟩. If A and B are MPOs, computes the Frobenius inner product.\n\nUse loginner to avoid underflow/overflow for taking overlaps of large MPS or MPO.\n\ncompat: ITensors 0.3\n\n\nBefore ITensors 0.3, inner had a keyword argument make_inds_match that default to true.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.\n\nSame as dot.\n\nSee also loginner, logdot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","page":"MPS and MPO","title":"LinearAlgebra.dot","text":"dot(A::MPS, B::MPS)\ndot(A::MPO, B::MPO)\n\nSame as inner.\n\nSee also loginner, logdot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","page":"MPS and MPO","title":"ITensorMPS.loginner","text":"loginner(A::MPS, B::MPS)\nloginner(A::MPO, B::MPO)\n\nCompute the logarithm of the inner product ⟨A|B⟩. If A and B are MPOs, computes the logarithm of the Frobenius inner product.\n\nThis is useful for larger MPS/MPO, where in the limit of large numbers of sites the inner product can diverge or approach zero.\n\ncompat: ITensors 0.3\n\n\nBefore ITensors 0.3, inner had a keyword argument make_inds_match that default to true.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.\n\nSame as logdot.\n\nSee also inner, dot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","page":"MPS and MPO","title":"ITensorMPS.logdot","text":"logdot(A::MPS, B::MPS)\nlogdot(A::MPO, B::MPO)\n\nSame as loginner.\n\nSee also inner, dot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.inner-Tuple{MPS, MPO, MPS}","page":"MPS and MPO","title":"ITensors.inner","text":"inner(y::MPS, A::MPO, x::MPS)\n\nCompute ⟨y|A|x⟩ = ⟨y|Ax⟩ efficiently and exactly without making any intermediate MPOs. In general it is more efficient and accurate than inner(y, apply(A, x)).\n\nThis is helpful for computing the expectation value of an operator A, which would be:\n\ninner(x', A, x)\n\nassuming x is normalized.\n\nIf you want to compute ⟨By|Ax⟩ you can use inner(B::MPO, y::MPS, A::MPO, x::MPS).\n\nThis is helpful for computing the variance of an operator A, which would be:\n\ninner(A, x, A, x) - inner(x', A, x) ^ 2\n\nassuming x is normalized.\n\ncompat: ITensors 0.3\n\n\nBefore ITensors 0.3, inner had a keyword argument make_inds_match that default to true.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.\n\nSame as dot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.dot-Tuple{MPS, MPO, MPS}","page":"MPS and MPO","title":"LinearAlgebra.dot","text":"dot(y::MPS, A::MPO, x::MPS)\n\nSame as inner.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.inner-Tuple{MPO, MPS, MPO, MPS}","page":"MPS and MPO","title":"ITensors.inner","text":"inner(B::MPO, y::MPS, A::MPO, x::MPS)\n\nCompute ⟨By|A|x⟩ = ⟨By|Ax⟩ efficiently and exactly without making any intermediate MPOs. In general it is more efficient and accurate than inner(apply(B, y), apply(A, x)).\n\nThis is helpful for computing the variance of an operator A, which would be:\n\ninner(A, x, A, x) - inner(x, A, x) ^ 2\n\ncompat: ITensors 0.3\n\n\nBefore ITensors 0.3, inner had a keyword argument make_inds_match that default to true.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.\n\nSame as dot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.dot-Tuple{MPO, MPS, MPO, MPS}","page":"MPS and MPO","title":"LinearAlgebra.dot","text":"dot(B::MPO, y::MPS, A::MPO, x::MPS)\n\nSame as inner.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.norm-Tuple{AbstractMPS}","page":"MPS and MPO","title":"LinearAlgebra.norm","text":"norm(A::MPS)\nnorm(A::MPO)\n\nCompute the norm of the MPS or MPO.\n\nIf the MPS or MPO has a well defined orthogonality center, this reduces to the norm of the orthogonality center tensor. Otherwise, it computes the norm with the full inner product of the MPS/MPO with itself.\n\nSee also lognorm.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.normalize-Tuple{AbstractMPS}","page":"MPS and MPO","title":"LinearAlgebra.normalize","text":"normalize(A::MPS; (lognorm!)=[])\nnormalize(A::MPO; (lognorm!)=[])\n\nReturn a new MPS or MPO A that is the same as the original MPS or MPO but with norm(A) ≈ 1.\n\nIn practice, this evenly spreads lognorm(A) over the tensors within the range of the orthogonality center to avoid numerical overflow in the case of diverging norms.\n\nSee also normalize!, norm, lognorm.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.normalize!-Tuple{AbstractMPS}","page":"MPS and MPO","title":"LinearAlgebra.normalize!","text":"normalize!(A::MPS; (lognorm!)=[])\nnormalize!(A::MPO; (lognorm!)=[])\n\nChange the MPS or MPO A in-place such that norm(A) ≈ 1. This modifies the data of the tensors within the orthogonality center.\n\nIn practice, this evenly spreads lognorm(A) over the tensors within the range of the orthogonality center to avoid numerical overflow in the case of diverging norms.\n\nIf the norm of the input MPS or MPO is 0, normalizing is ill-defined. In this case, we just return the original MPS or MPO. You can check for this case as follows:\n\ns = siteinds(\"S=1/2\", 4)\nψ = 0 * random_mps(s)\nlognorm_ψ = []\nnormalize!(ψ; (lognorm!)=lognorm_ψ)\nlognorm_ψ[1] == -Inf # There was an infinite norm\n\nSee also normalize, norm, lognorm.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.lognorm-Tuple{AbstractMPS}","page":"MPS and MPO","title":"ITensorMPS.lognorm","text":"lognorm(A::MPS)\nlognorm(A::MPO)\n\nCompute the logarithm of the norm of the MPS or MPO.\n\nThis is useful for larger MPS/MPO that are not gauged, where in the limit of large numbers of sites the norm can diverge or approach zero.\n\nSee also norm, logdot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:+-Tuple{Vararg{AbstractMPS}}","page":"MPS and MPO","title":"Base.:+","text":"+(A::MPS/MPO...; kwargs...)\nadd(A::MPS/MPO...; kwargs...)\n\nAdd arbitrary numbers of MPS/MPO with each other, optionally truncating the results.\n\nA cutoff of 1e-15 is used by default, and in general users should set their own cutoff for their particular application.\n\nKeywords\n\ncutoff::Real: singular value truncation cutoff\nmaxdim::Int: maximum MPS/MPO bond dimension\nalg = \"densitymatrix\": \"densitymatrix\" or \"directsum\". \"densitymatrix\" adds the MPS/MPO  by adding up and diagoanlizing local density matrices site by site in a single  sweep through the system, truncating the density matrix with cutoff and maxdim.  \"directsum\" performs a direct sum of each tensors on each site of the input  MPS/MPO being summed. It doesn't perform any truncation, and therefore ignores  cutoff and maxdim. The bond dimension of the output is the sum of the bond  dimensions of the inputs. You can truncate the resulting MPS/MPO with the truncate! function.\n\nExamples\n\nN = 10\n\ns = siteinds(\"S=1/2\", N; conserve_qns = true)\n\nstate = n -> isodd(n) ? \"↑\" : \"↓\"\nψ₁ = random_mps(s, state; linkdims=2)\nψ₂ = random_mps(s, state; linkdims=2)\nψ₃ = random_mps(s, state; linkdims=2)\n\nψ = +(ψ₁, ψ₂; cutoff = 1e-8)\n\n# Can use:\n#\n# ψ = ψ₁ + ψ₂\n#\n# but generally you want to set a custom `cutoff` and `maxdim`.\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₂) + inner(ψ₁, ψ₂) + inner(ψ₂, ψ₁) + inner(ψ₂, ψ₂)\n\n# Computes ψ₁ + 2ψ₂\nψ = ψ₁ + 2ψ₂\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + 2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂)\n\n# Computes ψ₁ + 2ψ₂ + ψ₃\nψ = ψ₁ + 2ψ₂ + ψ₃\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + inner(ψ₁, ψ₃) +\n      2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂) + 2 * inner(ψ₂, ψ₃) +\n      inner(ψ₃, ψ₁) + 2 * inner(ψ₃, ψ₂) + inner(ψ₃, ψ₃)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#NDTensors.contract-Tuple{MPO, MPS}","page":"MPS and MPO","title":"NDTensors.contract","text":"contract(ψ::MPS, A::MPO; kwargs...) -> MPS\n*(::MPS, ::MPO; kwargs...) -> MPS\n\ncontract(A::MPO, ψ::MPS; kwargs...) -> MPS\n*(::MPO, ::MPS; kwargs...) -> MPS\n\nContract the MPO A with the MPS ψ, returning an MPS with the unique site indices of the MPO.\n\nFor example, for an MPO with site indices with prime levels of 1 and 0, such as -s'-A-s-, and an MPS with site indices with prime levels of 0, such as -s-x, the result is an MPS y with site indices with prime levels of 1, -s'-y = -s'-A-s-x.\n\nSince it is common to contract an MPO with prime levels of 1 and 0 with an MPS with prime level of 0 and want a resulting MPS with prime levels of 0, we provide a convenience function apply:\n\napply(A, x; kwargs...) = replaceprime(contract(A, x; kwargs...), 2 => 1)`.\n\nChoose the method with the method keyword, for example \"densitymatrix\" and \"naive\".\n\nKeywords\n\ncutoff::Float64=1e-13: the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to  change, in general you should set a cutoff value.\nmaxdim::Int=maxlinkdim(A) * maxlinkdim(ψ)): the maximal bond dimension of the results MPS.\nmindim::Int=1: the minimal bond dimension of the resulting MPS.\nnormalize::Bool=false: whether or not to normalize the resulting MPS.\nmethod::String=\"densitymatrix\": the algorithm to use for the contraction.  Currently the options are \"densitymatrix\", where the network formed by the  MPO and MPS is squared and contracted down to a density matrix which is  diagonalized iteratively at each site, and \"naive\", where the MPO and MPS  tensor are contracted exactly at each site and then a truncation of the  resulting MPS is performed.\n\nSee also apply.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.apply-Tuple{MPO, MPS}","page":"MPS and MPO","title":"ITensors.apply","text":"apply(A::MPO, x::MPS; kwargs...)\n\nContract the MPO A with the MPS x and then map the prime level of the resulting MPS back to 0.\n\nEquivalent to replaceprime(contract(A, x; kwargs...), 2 => 1).\n\nSee also contract for details about the arguments available.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#NDTensors.contract-Tuple{MPO, MPO}","page":"MPS and MPO","title":"NDTensors.contract","text":"contract(A::MPO, B::MPO; kwargs...) -> MPO\n*(::MPO, ::MPO; kwargs...) -> MPO\n\nContract the MPO A with the MPO B, returning an MPO with the site indices that are not shared between A and B.\n\nIf you are contracting two MPOs with the same sets of indices, likely you want to call something like:\n\nC = contract(A', B; cutoff=1e-12)\nC = replaceprime(C, 2 => 1)\n\nThat is because if MPO A has the index structure -s'-A-s- and MPO B has the Index structure -s'-B-s-, if we only want to contract over on set of the indices, we would do (-s'-A-s-)'-s'-B-s- = -s''-A-s'-s'-B-s- = -s''-C-s-, and then map the prime levels back to pairs of primed and unprimed indices with: replaceprime(-s''-C-s-, 2 => 1) = -s'-C-s-.\n\nSince this is a common use case, you can use the convenience function:\n\nC = apply(A, B; cutoff=1e-12)\n\nwhich is the same as the code above.\n\nIf you are contracting MPOs that have diverging norms, such as MPOs representing sums of local operators, the truncation can become numerically unstable (see https://arxiv.org/abs/1909.06341 for a more numerically stable alternative). For now, you can use the following options to contract MPOs like that:\n\nC = contract(A, B; alg=\"naive\", truncate=false)\n# Bring the indices back to pairs of primed and unprimed\nC = apply(A, B; alg=\"naive\", truncate=false)\n\nKeywords\n\ncutoff::Float64=1e-14: the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to change,  in general you should set a cutoff value.\nmaxdim::Int=maxlinkdim(A) * maxlinkdim(B)): the maximal bond dimension of the results MPS.\nmindim::Int=1: the minimal bond dimension of the resulting MPS.\nalg=\"zipup\": Either \"zipup\" or \"naive\". \"zipup\" contracts pairs of  site tensors and truncates with SVDs in a sweep across the sites, while \"naive\"  first contracts pairs of tensor exactly and then truncates at the end if truncate=true.\ntruncate=true: Enable or disable truncation. If truncate=false, ignore  other truncation parameters like cutoff and maxdim. This is most relevant  for the \"naive\" version, if you just want to contract the tensors pairwise  exactly. This can be useful if you are contracting MPOs that have diverging  norms, such as MPOs originating from sums of local operators.\n\nSee also apply for details about the arguments available.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.apply-Tuple{MPO, MPO}","page":"MPS and MPO","title":"ITensors.apply","text":"apply(A::MPO, B::MPO; kwargs...)\n\nContract the MPO A' with the MPO B and then map the prime level of the resulting MPO back to having pairs of indices with prime levels of 1 and 0.\n\nEquivalent to replaceprime(contract(A', B; kwargs...), 2 => 1).\n\nSee also contract for details about the arguments available.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.error_contract-Tuple{MPS, MPO, MPS}","page":"MPS and MPO","title":"ITensorMPS.error_contract","text":"error_contract(y::MPS, A::MPO, x::MPS;\n               make_inds_match::Bool = true)\nerror_contract(y::MPS, x::MPS, A::MPO;\n               make_inds_match::Bool = true)\n\nCompute the distance between A|x> and an approximation MPS y: | |y> - A|x> |/| A|x> | = √(1 + (<y|y> - 2*real(<y|A|x>))/<Ax|A|x>).\n\nIf make_inds_match = true, the function attempts match the site indices of y with the site indices of A that are not common with x.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#NDTensors.outer-Tuple{MPS, MPS}","page":"MPS and MPO","title":"NDTensors.outer","text":"outer(x::MPS, y::MPS; <keyword argument>) -> MPO\n\nCompute the outer product of MPS x and MPS y, returning an MPO approximation. Note that y will be conjugated.\n\nIn Dirac notation, this is the operation |x⟩⟨y|.\n\nIf you want an outer product of an MPS with itself, you should call outer(x', x; kwargs...) so that the resulting MPO has site indices with indices coming in pairs of prime levels of 1 and 0. If not, the site indices won't be unique which would not be an outer product.\n\nFor example:\n\ns = siteinds(\"S=1/2\", 5)\nx = random_mps(s)\ny = random_mps(s)\nouter(x, y) # Incorrect! Site indices must be unique.\nouter(x', y) # Results in an MPO with pairs of primed and unprimed indices.\n\nThis allows for more general outer products, such as more general MPO outputs which don't have pairs of primed and unprimed indices, or outer products where the input MPS are vectorizations of MPOs.\n\nFor example:\n\ns = siteinds(\"S=1/2\", 5)\nX = MPO(s, \"Id\")\nY = MPO(s, \"Id\")\nx = convert(MPS, X)\ny = convert(MPS, Y)\nouter(x, y) # Incorrect! Site indices must be unique.\nouter(x', y) # Incorrect! Site indices must be unique.\nouter(addtags(x, \"Out\"), addtags(y, \"In\")) # This performs a proper outer product.\n\nThe keyword arguments determine the truncation, and accept the same arguments as contract(::MPO, ::MPO; kwargs...).\n\nSee also apply, contract.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensorMPS.projector-Tuple{MPS}","page":"MPS and MPO","title":"ITensorMPS.projector","text":"projector(x::MPS; <keyword argument>) -> MPO\n\nComputes the projector onto the state x. In Dirac notation, this is the operation |x⟩⟨x|/|⟨x|x⟩|².\n\nUse keyword arguments to control the level of truncation, which are the same as those accepted by contract(::MPO, ::MPO; kw...).\n\nKeywords\n\nnormalize::Bool=true: whether or not to normalize the input MPS before  forming the projector. If normalize==false and the input MPS is not  already normalized, this function will not output a proper project, and  simply outputs outer(x, x) = |x⟩⟨x|, i.e. the projector scaled by norm(x)^2.\ntruncation keyword arguments accepted by contract(::MPO, ::MPO; kw...).\n\nSee also outer, contract.\n\n\n\n\n\n","category":"method"},{"location":"examples/Physics.html#Physics-(SiteType)-System-Examples","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"","category":"section"},{"location":"examples/Physics.html#Obtaining-a-Predefined-Operator","page":"Physics (SiteType) System Examples","title":"Obtaining a Predefined Operator","text":"","category":"section"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Given an Index carrying a \"physical\" tag such as \"Qubit\", \"S=1/2\", \"Boson\", etc. there are a set of pre-defined operators for each tag. The entire set of operators can be found in the section SiteTypes Included with ITensor.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"If you have an Index s carrying a \"S=1/2\" tag, for example, you can obtain the \"Sz\" operator like this:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\n\nop(\"Sz\",s)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Usually indices with physical tags come from an array of indices returned from the siteinds function","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\n\nN = 10\nsites = siteinds(\"S=1/2\",N)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"in which case one might want the \"Sz\" operator on site 4","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nSz4 = op(\"Sz\",sites[4])","category":"page"},{"location":"examples/Physics.html#Make-a-Custom-Operator-from-a-Matrix","page":"Physics (SiteType) System Examples","title":"Make a Custom Operator from a Matrix","text":"","category":"section"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The op function can be passed any matrix, as long as it has the correct dimensions, and it will make this into an ITensor representing the operator with the corresponding matrix elements.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"For example, if we have a two-dimensional Index s we could make the \"Sz\" operator ourselves from the matrix","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"M = [1/2 0 ; 0 -1/2]","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"by calling","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nSz = op(M,s)","category":"page"},{"location":"examples/Physics.html#custom_op","page":"Physics (SiteType) System Examples","title":"Making a Custom op Definition","text":"","category":"section"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The function op is used to obtain operators defined for a given \"site type\". ITensor includes pre-defined site types such as \"S=1/2\", \"S=1\", \"Electron\" and others. Or you can define your own site type as discussed in detail in the code examples further below.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Extending op Function Definitions","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Perhaps the most common part of the site type system one wishes to extend are the various op or op! function overloads which allow code like","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\ns = siteind(\"S=1/2\")\nSz = op(\"Sz\",s)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"to automatically create the S^z operator for an Index s based on the \"S=1/2\" tag it carries. A major reason to define such op overloads is to allow the OpSum system to recognize new operator names, as discussed more below.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Let's see how to introduce a new operator name into the ITensor site type system for this existing site type of \"S=1/2\". The operator we will introduce is the projector onto the up spin state P_uparrow which we will denote with the string \"Pup\".","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"As a matrix acting on the space  uparrowrangle downarrowrangle , the P_uparrow operator is given by","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"beginaligned\n\nP_uparrow =\nbeginbmatrix\n 1   0 \n 0   0 \nendbmatrix\n\nendaligned","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"To add this operator to the ITensor op system, we just need to introduce the following code","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nITensors.op(::OpName\"Pup\",::SiteType\"S=1/2\") =\n [1 0\n  0 0]","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"This code can be defined anywhere, such as in your own personal application code and does not have to be put into the ITensor library source code.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Note that we have to name the function ITensors.op and not just op so that it overloads other functions of the name op inside the ITensors module.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Having defined the above code, we can now do things like","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\ns = siteind(\"S=1/2\")\nPup = op(\"Pup\",s)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"to obtain the \"Pup\" operator for our \"S=1/2\" Index s. Or we can do a similar thing for an array of site indices:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nN = 40\ns = siteinds(\"S=1/2\",N)\nPup1 = op(\"Pup\",s[1])\nPup3 = op(\"Pup\",s[3])","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Note that for the \"Qudit\"/\"Boson\" site types, you have to define your overload of op with the dimension of the local Hilbert space, for example:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nfunction ITensors.op(::OpName\"P1\", ::SiteType\"Boson\", d::Int)\n  o = zeros(d, d)\n  o[1, 1] = 1\n  return o\nend","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Alternatively you could use Julia's array comprehension syntax:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nITensors.op(::OpName\"P1\", ::SiteType\"Boson\", d::Int) =\n  [(i == j == 1) ? 1.0 : 0.0 for i in 1:d, j in 1:d]","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Using Custom Operators in OpSum","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"A key use of these op system extensions is allowing additional operator names to be recognized by the OpSum system for constructing matrix product operator (MPO) tensor networks. With the code above defining the \"Pup\" operator, we are now allowed to use this operator name in any OpSum code involving \"S=1/2\" site indices.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"For example, we could now make an OpSum involving our custom operator such as:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=1/2\",N)\nos = OpSum()\nfor n=1:N\n  os += \"Pup\",n\nend\nP = MPO(os,sites)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"This code makes an MPO P which is just the sum of a spin-up projection operator acting on every site.","category":"page"},{"location":"examples/Physics.html#Making-a-Custom-state-Definition","page":"Physics (SiteType) System Examples","title":"Making a Custom state Definition","text":"","category":"section"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The function state is used to define states (single-site wavefunctions) that sites can be in. For example, the \"Qubit\" site type includes definitions for the \"0\" and \"1\" states as well as the \"+\" (eigenstate of X operator) state. The \"S=1/2\" site type includes definitions for the \"Up\" and \"Dn\" (down) states.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Say we want to define a new state for the \"Electron\" site type called \"+\", which has the meaning of one electron with its spin in the +X direction. First let's review the existing state definitions:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nITensors.state(::StateName\"Emp\", ::SiteType\"Electron\") = [1.0, 0, 0, 0]\nITensors.state(::StateName\"Up\", ::SiteType\"Electron\") = [0.0, 1, 0, 0]\nITensors.state(::StateName\"Dn\", ::SiteType\"Electron\") = [0.0, 0, 1, 0]\nITensors.state(::StateName\"UpDn\", ::SiteType\"Electron\") = [0.0, 0, 0, 1]","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"As we can see, the four settings of an \"Electron\" index correspond to the states 0rangle uparrowrangle downarrowrangle uparrowdownarrowrangle.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"So we can define our new state \"+\" as follows:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"ITensors.state(::StateName\"+\", ::SiteType\"Electron\") = [0, 1/sqrt(2), 1/sqrt(2), 0]","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"which makes the state","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"+rangle = frac1sqrt2 uparrowrangle + frac1sqrt2 downarrowrangle","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Having defined this overload of state, if we have an Index of type \"Electron\" we can obtain our new state for it by doing","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\ns = siteind(\"Electron\")\nplus = state(\"+\",s)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"We can also use this new state definition in other ITensor features such as the MPS constructor taking an array of state names.","category":"page"},{"location":"examples/Physics.html#Make-a-Custom-Local-Hilbert-Space-/-Physical-Degree-of-Freedom","page":"Physics (SiteType) System Examples","title":"Make a Custom Local Hilbert Space / Physical Degree of Freedom","text":"","category":"section"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"ITensor provides support for a range of common local Hilbert space types, or physical degrees of freedom, such as S=1/2 and S=1 spins; spinless and spinful fermions; and more.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"However, there can be many cases where you need to make custom degrees of freedom. You might be working with an exotic system, such as Z_N parafermions for example, or need to customize other defaults provided by ITensor.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"In ITensor, such a customization is done by overloading functions on specially designated Index tags. Below we give an brief introduction by example of how to make such custom Index site types in ITensor. Other code formulas following this one explain how to build on this example to expand the capabilities of your custom site type such as adding support for quantum number (QN) conservation and defining custom mappings of strings to states.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Throughout we will focus on the example of S=32 spins. These are spins taking the S^z values of +32+12-12-32. So as tensor indices, they are indices of dimension 4.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The key operators we will make for this example are S^z, S^+, and S^-, which are defined as:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"beginaligned\nS^z =\nbeginbmatrix\n32   0    0    0 \n 0   12   0    0 \n 0    0  -12   0 \n 0    0    0  -32\nendbmatrix \n\nS^+  =\nbeginbmatrix\n 0    sqrt3    0    0 \n 0    0    2    0 \n 0    0    0    sqrt3 \n 0    0    0    0 \nendbmatrix \n\nS^-  =\nbeginbmatrix\n 0    0   0    0 \n sqrt3    0    0    0 \n 0    2    0    0  \n 0    0    sqrt3    0 \nendbmatrix \nendaligned","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Code Preview","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"First let's see the minimal code needed to define and use this new S=32 site type, then we will discuss what each part of the code is doing.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\n\nITensors.space(::SiteType\"S=3/2\") = 4\n\nITensors.op(::OpName\"Sz\",::SiteType\"S=3/2\") =\n  [+3/2   0    0    0\n     0  +1/2   0    0\n     0    0  -1/2   0\n     0    0    0  -3/2]\n\nITensors.op(::OpName\"S+\",::SiteType\"S=3/2\") =\n  [0  √3  0  0\n   0   0  2  0\n   0   0  0 √3\n   0   0  0  0]\n\nITensors.op(::OpName\"S-\",::SiteType\"S=3/2\") =\n  [0   0  0   0\n   √3  0  0   0\n   0   2  0   0\n   0   0  √3  0]\n","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Now let's look at each part of the code above.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The SiteType","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The most important aspect of this code is a special type, known as a SiteType, which is a type made from a string. The string of interest here will be an Index tag. In the code above, the SiteType we are using is","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"SiteType\"S=3/2\"","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"What is the purpose of a SiteType? The answer is that we would like to be able to select different functions to call on an ITensor Index based on what tags it has, but that is not directly possible in Julia or indeed most languages. However, if we can map a tag to a type in the Julia type system, we can create function overloads for that type. ITensor does this for certain functions for you, and we will discuss a few of these functions below. So if the code encounters an Index such as Index(4,\"S=3/2\") it can call these functions which are specialized for indices carrying the \"S=3/2\" tag.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The space Function","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"One of the overloadable SiteType functions is space, whose job is to describe the vector space corresponding to that site type. For our SiteType\"S=3/2\" overload of space, which gets called for any Index carrying the \"S=3/2\" tag, the definition is","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nITensors.space(::SiteType\"S=3/2\") = 4","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Note that the function name is prepended with ITensors. before space. This prefix makes sure the function is overloading other versions of the space inside the ITensors module.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The only information needed about the vector space of a \"S=3/2\" Index in this example is that it is of dimension four. So the space function returns the integer 4. We will see in more advanced examples that the returned value can instead be an array which specifies not only the dimension of a \"S=3/2\" Index, but also additional subspace structure it has corresponding to quantum numbers.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"After defining this space function, you can just write code like:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\ns = siteind(\"S=3/2\")","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"to obtain a single \"S=3/2\" Index, or write code like","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=3/2\",N)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"to obtain an array of N \"S=3/2\" indices. The custom space function will be used to determine the dimension of these indices, and the siteind or siteinds functions provided by ITensor will help with extra things like putting other Index tags that are conventional for site indices.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The op Function","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The op function lets you define custom local operators associated to the physical degrees of freedom of your SiteType. Then for example you can use indices carrying your custom tag with OpSum and the OpSum system will know how to automatically convert names of operators such as \"Sz\" or \"S+\" into ITensors so that it can make an actual MPO.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"In our example above, we defined this function for the case of the \"Sz\" operator as:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nITensors.op(::OpName\"Sz\",::SiteType\"S=3/2\") =\n  [+3/2   0    0    0\n     0  +1/2   0    0\n     0    0  -1/2   0\n     0    0    0  -3/2]","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"As you can see, the function is passed two objects: an OpName and a SiteType. The strings \"Sz\" and \"S=3/2\" are also part of the type of these objects, and have the meaning of which operator name we are defining and which site type these operators are defined for.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The body of this overload of ITensors.op constructs and returns a Julia matrix which gives the matrix elements of the operator we are defining.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Once this function is defined, and if you have an Index such as","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"s = Index(4,\"S=3/2\")","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"then, for example, you can get the \"Sz\" operator for this Index and print it out by doing:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nSz = op(\"Sz\",s)\nprintln(Sz)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Again, through the magic of the SiteType system, the ITensor library takes your Index, reads off its tags, notices that one of them is \"S=3/2\", and converts this into the type SiteType\"S=3/2\" in order to call the specialized function ITensors.op defined above.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"You can use the op function yourself with a set of site indices created from the siteinds function like this:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=3/2\",N)\nSz1 = op(\"Sz\",sites[1])\nSp3 = op(\"S+\",sites[3])","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Alternatively, you can write the lines of code above in the style of Sz1 = op(\"Sz\",sites,1).","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"This same op function is used inside of OpSum (formerly called AutoMPO) when it converts its input into an actual MPO. So by defining custom operator names you can pass any of these operator names into OpSum and it will know how to use these operators.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Further Steps","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"See how the built-in site types are defined inside the ITensor library:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"S=1/2 sites - Dimension 2 local Hilbert space. Similar to the \"Qubit\" site type, shares many of the same operator definitions.\nQubit sites - Dimension 2 local Hilbert space. Similar to the \"S=1/2\" site type, shares many of the same operator definitions.\nS=1 sites - Dimension 3 local Hilbert space.\nFermion sites - Dimension 2 local Hilbert space. Spinless fermion site type.\nElectron sites - Dimension 4 local Hilbert space. Spinfull fermion site type.\ntJ sites - Dimension 3 local Hilbert space. Spinfull fermion site type but without a doubly occupied state in the Hilbert space.\nBoson sites - General d-dimensional local Hilbert space. Shares the same operator definitions as the \"Qudit\" site type.\nQudit sites - General d-dimensional local Hilbert space. Generalization of the \"Qubit\" site type, shares the same operator definitions as the Boson site type.","category":"page"},{"location":"examples/Physics.html#Make-a-Custom-Local-Hilbert-Space-with-QNs","page":"Physics (SiteType) System Examples","title":"Make a Custom Local Hilbert Space with QNs","text":"","category":"section"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"In the previous example above, we discussed the basic, minimal code needed to define a custom local Hilbert space, using the example of a S=32 spin Hilbert space. In those examples, the space function defining the vector space of a S=32 spin only provides the dimension of the space. But the Hilbert space of a S=32 spin has additional structure, which is that each of its four subspaces (each of dimension 1) can be labeled by a different S^z quantum number.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"In this code formula we will include this extra quantum information in the definition of the space of a S=32 spin.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Code Preview","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"First let's see the minimal code needed to add the option for including quantum numbers of our S=32 site type, then we will discuss what each part of the code is doing.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\n\nfunction ITensors.space(::SiteType\"S=3/2\";\n                        conserve_qns=false)\n  if conserve_qns\n    return [QN(\"Sz\",3)=>1,QN(\"Sz\",1)=>1,\n            QN(\"Sz\",-1)=>1,QN(\"Sz\",-3)=>1]\n  end\n  return 4\nend\n\nITensors.op(::OpName\"Sz\",::SiteType\"S=3/2\") =\n  [+3/2   0    0    0\n     0  +1/2   0    0\n     0    0  -1/2   0\n     0    0    0  -3/2]\n\nITensors.op(::OpName\"S+\",::SiteType\"S=3/2\") =\n  [0  √3  0  0\n   0   0  2  0\n   0   0  0 √3\n   0   0  0  0]\n\nITensors.op(::OpName\"S-\",::SiteType\"S=3/2\") =\n  [0   0  0   0\n   √3  0  0   0\n   0   2  0   0\n   0   0  √3  0]\n\n","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Now let's look at each part of the code above.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The space function","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"In the previous code example above, we discussed that the function space tells the ITensor library the basic information about how to construct an Index associated with a special Index tag, in this case the tag \"S=3/2\". As in that code formula, if the user does not request that quantum numbers be included (the case conserve_qns=false) then all that the space function returns is the number 4, indicating that a \"S=3/2\" Index should be of dimension 4.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"But if the conserve_qns keyword argument gets set to true, the space function we defined above returns an array of QN=>Int pairs. (The notation a=>b in Julia constructs a Pair object.) Each pair in the array denotes a subspace. The QN part of each pair says what quantum number the subspace has, and the integer following it indicates the dimension of the subspace.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"After defining the space function this way, you can write code like:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\ns = siteind(\"S=3/2\"; conserve_qns=true)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"to obtain a single \"S=3/2\" Index which carries quantum number information. The siteind function built into ITensor relies on your custom space function to ask how to construct a \"S=3/2\" Index but also includes some other Index tags which are conventional for all site indices.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"You can now also call code like:","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=3/2\",N; conserve_qns=true)","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"to obtain an array of N \"S=3/2\" indices which carry quantum numbers.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"The op Function in the Quantum Number Case","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"Note that the op function overloads are exactly the same as for the more basic case of defining an \"S=3/2\" Index type that does not carry quantum numbers. There is no need to upgrade any of the op functions for the QN-conserving case. The reason is that all QN, block-sparse information about an ITensor is deduced from the indices of the tensor, and setting elements of such tensors does not require any other special code.","category":"page"},{"location":"examples/Physics.html","page":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","text":"However, only operators which have a well-defined QN flux–-meaning they always change the quantum number of a state they act on by a well-defined amount–-can be used in practice in the case of QN conservation. Attempting to build an operator, or any ITensor, without a well-defined QN flux out of QN-conserving indices will result in a run time error. An example of an operator that would lead to such an error would be the \"Sx\" spin operator since it alternately increases S^z or decreases S^z depending on the state it acts on, thus it does not have a well-defined QN flux. But it is perfectly fine to define an op overload for the \"Sx\" operator and to make this operator when working with dense, non-QN-conserving ITensors or when S^z is not conserved.","category":"page"},{"location":"tutorials/DMRG.html#dmrg_tutorial","page":"DMRG","title":"DMRG Tutorial","text":"","category":"section"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"The density matrix renormalization group (DMRG) is an algorithm for computing eigenstates of Hamiltonians (or extremal eigenvectors of large, Hermitian matrices). It computes these eigenstates in the matrix product state (MPS) format.","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"Let's see how to set up and run a DMRG calculation using the ITensor library. We will be interested in finding the ground state of the quantum Hamiltonian H given by:","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"H = sum_j=1^N-1 mathbfS_j cdot mathbfS_j+1 = sum_j=1^N-1 S^z_j S^z_j+1 + frac12 S^+_j S^-_j+1 + frac12 S^-_j S^+_j+1","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"This Hamiltonian is known as the one-dimensional Heisenberg model and we will take the spins to be S=1 spins (spin-one spins). We will consider the case of N=100 and plan to do five sweeps of DMRG (five passes over the system).","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"ITensor DMRG Code","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"Let's look at an entire, working ITensor code that will do this calculation then discuss the main steps. If you need help running the code below, see the getting started page on Running ITensor and Julia Codes.","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"using ITensors, ITensorMPS\nlet\n  N = 100\n  sites = siteinds(\"S=1\",N)\n\n  os = OpSum()\n  for j=1:N-1\n    os += \"Sz\",j,\"Sz\",j+1\n    os += 1/2,\"S+\",j,\"S-\",j+1\n    os += 1/2,\"S-\",j,\"S+\",j+1\n  end\n  H = MPO(os,sites)\n\n  psi0 = random_mps(sites;linkdims=10)\n\n  nsweeps = 5\n  maxdim = [10,20,100,100,200]\n  cutoff = [1E-10]\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"Steps of The Code","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"The first two lines","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=1\",N)","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"tells the function siteinds to make an array of ITensor Index objects which have the properties of S=1 spins. This means their dimension will be 3 and they will carry the \"S=1\" tag, which will enable the next part of the code to know how to make appropriate operators for them.","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"Try printing out some of these indices to verify their properties:","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"@show sites[1]","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"The next part of the code builds the Hamiltonian:","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"os = OpSum()\nfor j=1:N-1\n  os += \"Sz\",j,\"Sz\",j+1\n  os += 1/2,\"S+\",j,\"S-\",j+1\n  os += 1/2,\"S-\",j,\"S+\",j+1\nend\nH = MPO(os,sites)","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"An OpSum is an object which accumulates Hamiltonian terms such as \"Sz\",1,\"Sz\",2 so that they can be summed afterward into a matrix product operator (MPO) tensor network. The line of code H = MPO(os,sites) constructs the Hamiltonian in the MPO format, with physical indices given by the array sites.","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"The line","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"psi0 = random_mps(sites;linkdims=10)","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"constructs an MPS psi0 which has the physical indices sites and a bond dimension of 10. It is made by a random quantum circuit that is reshaped into an MPS, so that it will have as generic and unbiased properties as an MPS of that size can have. This choice can help prevent the DMRG calculation from getting stuck in a local minimum.","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"The lines","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"nsweeps = 5\nmaxdim = [10,20,100,100,200]\ncutoff = [1E-10]","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"define the number of DMRG sweeps (five) we will instruct the code to do, as well as the parameters that will control the speed and accuracy of the DMRG algorithm within each sweep. The array maxdim limits the maximum MPS bond dimension allowed during each sweep and cutoff defines the truncation error goal of each sweep (if fewer values are specified than sweeps, the last value is used for all remaining sweeps).","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"Finally the call","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"runs the DMRG algorithm included in ITensor, using psi0 as an initial guess for the ground state wavefunction. The optimized MPS psi and its eigenvalue energy are returned.","category":"page"},{"location":"tutorials/DMRG.html","page":"DMRG","title":"DMRG","text":"After the dmrg function returns, you can take the returned MPS psi and do further calculations with it, such as measuring local operators or computing entanglement entropy.","category":"page"},{"location":"ProjMPO.html#ProjMPO","page":"ProjMPO","title":"ProjMPO","text":"","category":"section"},{"location":"ProjMPO.html#Description","page":"ProjMPO","title":"Description","text":"","category":"section"},{"location":"ProjMPO.html","page":"ProjMPO","title":"ProjMPO","text":"ProjMPO","category":"page"},{"location":"ProjMPO.html#ITensorMPS.ProjMPO","page":"ProjMPO","title":"ITensorMPS.ProjMPO","text":"A ProjMPO computes and stores the projection of an MPO into a basis defined by an MPS, leaving a certain number of site indices of the MPO unprojected. Which sites are unprojected can be shifted by calling the position! method.\n\nDrawing of the network represented by a ProjMPO P(H), showing the case of nsite(P)==2 and position!(P,psi,4) for an MPS psi:\n\no--o--o-      -o--o--o--o--o--o <psi|\n|  |  |  |  |  |  |  |  |  |  |\no--o--o--o--o--o--o--o--o--o--o H\n|  |  |  |  |  |  |  |  |  |  |\no--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPO.html#Methods","page":"ProjMPO","title":"Methods","text":"","category":"section"},{"location":"ProjMPO.html","page":"ProjMPO","title":"ProjMPO","text":"product(::ProjMPO,::ITensor)\nposition!(::ProjMPO, ::MPS, ::Int)\nnoiseterm(::ProjMPO,::ITensor,::String)","category":"page"},{"location":"ProjMPO.html#ITensors.product-Tuple{ProjMPO, ITensor}","page":"ProjMPO","title":"ITensors.product","text":"product(P::ProjMPO,v::ITensor)::ITensor\n\n(P::ProjMPO)(v::ITensor)\n\nEfficiently multiply the ProjMPO P by an ITensor v in the sense that the ProjMPO is a generalized square matrix or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensorMPS.position!-Tuple{ProjMPO, MPS, Int64}","page":"ProjMPO","title":"ITensorMPS.position!","text":"position!(P::ProjMPO, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPO P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPO on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensorMPS.noiseterm-Tuple{ProjMPO, ITensor, String}","page":"ProjMPO","title":"ITensorMPS.noiseterm","text":"noiseterm(P::ProjMPO,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the ProjMPO P, and ortho is a String which can take the values \"left\" or \"right\" depending on the sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Properties","page":"ProjMPO","title":"Properties","text":"","category":"section"},{"location":"ProjMPO.html","page":"ProjMPO","title":"ProjMPO","text":"length(::ProjMPO)\neltype(::ProjMPO)\nsize(::ProjMPO)","category":"page"},{"location":"ProjMPO.html#Base.length-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.length","text":"length(P::ProjMPO)\n\nThe length of a ProjMPO is the same as the length of the MPO used to construct it\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.eltype-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.eltype","text":"eltype(P::ProjMPO)\n\nDeduce the element type (such as Float64 or ComplexF64) of the tensors in the ProjMPO P.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.size-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.size","text":"size(P::ProjMPO)\n\nThe size of a ProjMPO are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d.\n\nFor example, if a ProjMPO maps from a space with indices (a,s1,s2,b) to the space (a',s1',s2',b') then the size is (d,d) where d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ProjMPOSum","page":"ProjMPOSum","title":"ProjMPOSum","text":"","category":"section"},{"location":"ProjMPOSum.html#Description","page":"ProjMPOSum","title":"Description","text":"","category":"section"},{"location":"ProjMPOSum.html","page":"ProjMPOSum","title":"ProjMPOSum","text":"ProjMPOSum","category":"page"},{"location":"ProjMPOSum.html#ITensorMPS.ProjMPOSum","page":"ProjMPOSum","title":"ITensorMPS.ProjMPOSum","text":"A ProjMPOSum computes and stores the projection of an implied sum of MPOs into a basis defined by an MPS, leaving a certain number of site indices of each MPO unprojected. Which sites are unprojected can be shifted by calling the position! method. The MPOs used as input to a ProjMPOSum are not added together beforehand; instead when the product method of a ProjMPOSum is invoked, each projected MPO in the set of MPOs is multiplied by the input tensor one-by-one in an efficient way.\n\nDrawing of the network represented by a ProjMPOSum P([H1,H2,...]), showing the case of nsite(P)==2 and position!(P,psi,4) for an MPS psi (note the sum Σⱼ on the left):\n\n     o--o--o-      -o--o--o--o--o--o <psi|\n     |  |  |  |  |  |  |  |  |  |  |\n Σⱼ  o--o--o--o--o--o--o--o--o--o--o Hⱼ\n     |  |  |  |  |  |  |  |  |  |  |\n     o--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPOSum.html#Methods","page":"ProjMPOSum","title":"Methods","text":"","category":"section"},{"location":"ProjMPOSum.html","page":"ProjMPOSum","title":"ProjMPOSum","text":"product(::ProjMPOSum,::ITensor)\nposition!(::ProjMPOSum, ::MPS, ::Int)\nnoiseterm(::ProjMPOSum,::ITensor,::String)","category":"page"},{"location":"ProjMPOSum.html#ITensors.product-Tuple{ProjMPOSum, ITensor}","page":"ProjMPOSum","title":"ITensors.product","text":"product(P::ProjMPOSum,v::ITensor)\n\n(P::ProjMPOSum)(v::ITensor)\n\nEfficiently multiply the ProjMPOSum P by an ITensor v in the sense that the ProjMPOSum is a generalized square matrix or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensorMPS.position!-Tuple{ProjMPOSum, MPS, Int64}","page":"ProjMPOSum","title":"ITensorMPS.position!","text":"position!(P::ProjMPOSum, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPOSum P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPOs on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensorMPS.noiseterm-Tuple{ProjMPOSum, ITensor, String}","page":"ProjMPOSum","title":"ITensorMPS.noiseterm","text":"noiseterm(P::ProjMPOSum,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the ProjMPOSum P, and ortho is a String which can take the values \"left\" or \"right\" depending on the sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Properties","page":"ProjMPOSum","title":"Properties","text":"","category":"section"},{"location":"ProjMPOSum.html","page":"ProjMPOSum","title":"ProjMPOSum","text":"eltype(::ProjMPOSum)\nsize(::ProjMPOSum)","category":"page"},{"location":"ProjMPOSum.html#Base.eltype-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.eltype","text":"eltype(P::ProjMPOSum)\n\nDeduce the element type (such as Float64 or ComplexF64) of the tensors in the ProjMPOSum P.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Base.size-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.size","text":"size(P::ProjMPOSum)\n\nThe size of a ProjMPOSum are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d.\n\nFor example, if a ProjMPOSum maps from a space with indices (a,s1,s2,b) to the space (a',s1',s2',b') then the size is (d,d) where d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"SiteType.html#SiteType-and-op,-state,-val-functions","page":"SiteType and op, state, val functions","title":"SiteType and op, state, val functions","text":"","category":"section"},{"location":"SiteType.html#Description","page":"SiteType and op, state, val functions","title":"Description","text":"","category":"section"},{"location":"SiteType.html","page":"SiteType and op, state, val functions","title":"SiteType and op, state, val functions","text":"SiteType","category":"page"},{"location":"SiteType.html#ITensors.SiteTypes.SiteType","page":"SiteType and op, state, val functions","title":"ITensors.SiteTypes.SiteType","text":"SiteType is a parameterized type which allows making Index tags into Julia types. Use cases include overloading functions such as op, siteinds, and state which generate custom operators, Index arrays, and IndexVals associated with Index objects having a certain tag.\n\nTo make a SiteType type, you can use the string macro notation: SiteType\"MyTag\"\n\nTo make a SiteType value or object, you can use the notation: SiteType(\"MyTag\")\n\nThere are currently a few built-in site types recognized by jl. The system is easily extensible by users. To add new operators to an existing site type, or to create new site types, you can follow the instructions here.\n\nThe current built-in site types are:\n\nSiteType\"S=1/2\" (or SiteType\"S=½\")\nSiteType\"S=1\"\nSiteType\"Qubit\"\nSiteType\"Qudit\"\nSiteType\"Boson\"\nSiteType\"Fermion\"\nSiteType\"tJ\"\nSiteType\"Electron\"\n\nExamples\n\nTags on indices get turned into SiteTypes internally, and then we search for overloads of functions like op and siteind. For example:\n\njulia> s = siteind(\"S=1/2\")\n(dim=2|id=862|\"S=1/2,Site\")\n\njulia> @show op(\"Sz\", s);\nop(s, \"Sz\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.5   0.0\n 0.0  -0.5\n\njulia> @show op(\"Sx\", s);\nop(s, \"Sx\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.0  0.5\n 0.5  0.0\n\njulia> @show op(\"Sy\", s);\nop(s, \"Sy\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Complex{Float64},Array{Complex{Float64},1}}\n 2×2\n 0.0 + 0.0im  -0.0 - 0.5im\n 0.0 + 0.5im   0.0 + 0.0im\n\njulia> s = siteind(\"Electron\")\n(dim=4|id=734|\"Electron,Site\")\n\njulia> @show op(\"Nup\", s);\nop(s, \"Nup\") = ITensor ord=2\nDim 1: (dim=4|id=734|\"Electron,Site\")'\nDim 2: (dim=4|id=734|\"Electron,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 4×4\n 0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\nMany operators are available, for example:\n\nSiteType\"S=1/2\": \"Sz\", \"Sx\", \"Sy\", \"S+\", \"S-\", ...\nSiteType\"Electron\": \"Nup\", \"Ndn\", \"Nupdn\", \"Ntot\", \"Cup\",  \"Cdagup\", \"Cdn\", \"Cdagdn\", \"Sz\", \"Sx\", \"Sy\", \"S+\", \"S-\", ...\n...\n\nYou can view the internal SiteType definitions and operators here.\n\n\n\n\n\n","category":"type"},{"location":"SiteType.html#Methods","page":"SiteType and op, state, val functions","title":"Methods","text":"","category":"section"},{"location":"SiteType.html","page":"SiteType and op, state, val functions","title":"SiteType and op, state, val functions","text":"op\nstate\nval\nspace","category":"page"},{"location":"SiteType.html#ITensors.SiteTypes.op","page":"SiteType and op, state, val functions","title":"ITensors.SiteTypes.op","text":"op(opname::String, s::Index; kwargs...)\n\nReturn an ITensor corresponding to the operator named opname for the Index s. The operator is constructed by calling an overload of either the op or op! methods which take a SiteType argument that corresponds to one of the tags of the Index s and an OpName\"opname\" argument that corresponds to the input operator name.\n\nOperator names can be combined using the \"*\" symbol, for example \"S+*S-\" or \"Sz*Sz*Sz\". The result is an ITensor made by forming each operator then contracting them together in a way corresponding to the usual operator product or matrix multiplication.\n\nThe op system is used by the OpSum system to convert operator names into ITensors, and can be used directly such as for applying operators to MPS.\n\nExample\n\ns = Index(2, \"Site,S=1/2\")\nSz = op(\"Sz\", s)\n\nYou can see all of the operator names defined for the site types included with ITensor here. Note that some site types such as \"S=1/2\" and \"Qubit\" are aliases for each other and share operator definitions.\n\n\n\n\n\nop(X::AbstractArray, s::Index...)\nop(M::Matrix, s::Index...)\n\nGiven a matrix M and a set of indices s,t,... return an operator ITensor with matrix elements given by M and indices s, s', t, t'\n\nExample\n\njulia> s = siteind(\"S=1/2\")\n(dim=2|id=575|\"S=1/2,Site\")\n\njulia> Sz = op([1/2 0; 0 -1/2],s)\nITensor ord=2 (dim=2|id=575|\"S=1/2,Site\")' (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n\njulia> @show Sz\nSz = ITensor ord=2\nDim 1: (dim=2|id=575|\"S=1/2,Site\")'\nDim 2: (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n 2×2\n 0.5   0.0\n 0.0  -0.5\nITensor ord=2 (dim=2|id=575|\"S=1/2,Site\")' (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n\n\n\n\n\nop(opname::String,sites::Vector{<:Index},n::Int; kwargs...)\n\nReturn an ITensor corresponding to the operator named opname for the n'th Index in the array sites.\n\nExample\n\ns = siteinds(\"S=1/2\", 4)\nSz2 = op(\"Sz\", s, 2)\n\n\n\n\n\n","category":"function"},{"location":"SiteType.html#ITensors.SiteTypes.state","page":"SiteType and op, state, val functions","title":"ITensors.SiteTypes.state","text":"state(s::Index, name::String; kwargs...)\n\nReturn an ITensor corresponding to the state named name for the Index s. The returned ITensor will have s as its only index.\n\nThe terminology here is based on the idea of a single-site state or wavefunction in physics.\n\nThe state function is implemented for various Index tags by overloading either the state or state! methods which take a SiteType argument corresponding to one of the tags of the Index s and an StateName\"name\" argument that corresponds to the input state name.\n\nThe state system is used by the MPS type to construct product-state MPS and for other purposes.\n\nExample\n\ns = Index(2, \"Site,S=1/2\")\nsup = state(s,\"Up\")\nsdn = state(s,\"Dn\")\nsxp = state(s,\"X+\")\nsxm = state(s,\"X-\")\n\n\n\n\n\n","category":"function"},{"location":"SiteType.html#ITensors.val","page":"SiteType and op, state, val functions","title":"ITensors.val","text":"val(q::QN,name)\n\nGet the value within the QN q corresponding to the string name\n\n\n\n\n\nval(s::Index, name::String)\n\nReturn an integer corresponding to the name of a certain value the Index s can take. In other words, the val function maps strings to specific integer values within the range 1:dim(s).\n\nThe val function is implemented for various Index tags by overloading methods named val which take a SiteType argument corresponding to one of the tags of the Index s and an ValName\"name\" argument that corresponds to the input name.\n\nExample\n\ns = Index(2, \"Site,S=1/2\")\nval(s,\"Up\") == 1\nval(s,\"Dn\") == 2\n\ns = Index(2, \"Site,Fermion\")\nval(s,\"Emp\") == 1\nval(s,\"Occ\") == 2\n\n\n\n\n\n","category":"function"},{"location":"SiteType.html#ITensors.space","page":"SiteType and op, state, val functions","title":"ITensors.space","text":"space(::SiteType\"Qubit\";\n      conserve_qns = false,\n      conserve_parity = conserve_qns,\n      conserve_number = false,\n      qnname_parity = \"Parity\",\n      qnname_number = \"Number\")\n\nCreate the Hilbert space for a site of type \"Qubit\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\nspace(::SiteType\"S=1/2\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_szparity = false,\n      qnname_sz = \"Sz\",\n      qnname_szparity = \"SzParity\")\n\nCreate the Hilbert space for a site of type \"S=1/2\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\nspace(::SiteType\"S=1\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      qnname_sz = \"Sz\")\n\nCreate the Hilbert space for a site of type \"S=1\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\nspace(::SiteType\"Fermion\";\n      conserve_qns=false,\n      conserve_nf=conserve_qns,\n      conserve_nfparity=conserve_qns,\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\",\n      qnname_sz = \"Sz\",\n      conserve_sz = false)\n\nCreate the Hilbert space for a site of type \"Fermion\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\nspace(::SiteType\"Electron\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_nf = conserve_qns,\n      conserve_nfparity = conserve_qns,\n      qnname_sz = \"Sz\",\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\")\n\nCreate the Hilbert space for a site of type \"Electron\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\nspace(::SiteType\"tJ\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_nf = conserve_qns,\n      conserve_nfparity = conserve_qns,\n      qnname_sz = \"Sz\",\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\")\n\nCreate the Hilbert space for a site of type \"tJ\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\nspace(::SiteType\"Qudit\";\n      dim = 2,\n      conserve_qns = false,\n      conserve_number = false,\n      qnname_number = \"Number\")\n\nCreate the Hilbert space for a site of type \"Qudit\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\nspace(::SiteType\"Boson\";\n      dim = 2,\n      conserve_qns = false,\n      conserve_number = false,\n      qnname_number = \"Number\")\n\nCreate the Hilbert space for a site of type \"Boson\".\n\nOptionally specify the conserved symmetries and their quantum number labels.\n\n\n\n\n\n","category":"function"},{"location":"IncludedSiteTypes.html#SiteTypes-Included-with-ITensor","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"","category":"section"},{"location":"IncludedSiteTypes.html#\"S1/2\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"S=1/2\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Site indices with the \"S=1/2\" site type represent S=12 spins with the states uparrowrangle, downarrowrangle.","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Making a single \"S=1/2\" site or collection of N \"S=1/2\" sites","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"s = siteind(\"S=1/2\")\nsites = siteinds(\"S=1/2\",N)","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"conserve_qns (default: false): conserve total S^z\nconserve_sz (default: conserve_qns): conserve total S^z\nconserve_szparity (default: false): conserve total S^z modulo two\nqnname_sz (default: \"Sz\"): name of total S^z QN\nqnname_szparity (default: \"SzParity\"): name of total S^z modulo two QN","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"For example:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"sites = siteinds(\"S=1/2\",N; conserve_szparity=true, qnname_szparity=\"SzP\")","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Operators associated with \"S=1/2\" sites can be made using the op function, for example","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Sz = op(\"Sz\",s)\nSz4 = op(\"Sz\",sites[4])","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available operators are exactly the same as those for the \"Qubit\" site type. Please see the list of \"Qubit\" operators below.","category":"page"},{"location":"IncludedSiteTypes.html#\"Qubit\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"Qubit\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Site indices with the \"Qubit\" site type represent qubits with the states 0rangle, 1rangle.","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Making a single \"Qubit\" site or collection of N \"Qubit\" sites","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"s = siteind(\"Qubit\")\nsites = siteinds(\"Qubit\",N)","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"conserve_qns (default: false): conserve total qubit parity\nconserve_parity (default: conserve_qns): conserve total qubit parity\nconserve_number (default: false): conserve total qubit number\nqnname_parity (default: \"Parity\"): name of total qubit parity QN\nqnname_number (default: \"Number\"): name of total qubit number QN","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"For example:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"sites = siteinds(\"Qubit\",N; conserve_parity=true)","category":"page"},{"location":"IncludedSiteTypes.html#\"Qubit\"-and-\"S1/2\"-States","page":"SiteTypes Included with ITensor","title":"\"Qubit\" and \"S=1/2\" States","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"The available state names for \"Qubit\" sites are:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"0\" (aliases: \"Z+\", \"Zp\", \"Up\", \"↑\") Qubit in the 0 state\n\"1\" (aliases: \"Z-\", \"Zm\", \"Dn\", \"↓\") Qubit in the 1 state\n\"+\" (aliases: \"X+\", \"Xp\") Qubit in the +rangle state (+1 eigenvector of sigma_x)\n\"+\" (aliases: \"X-\", \"Xm\") Qubit in the -rangle state (-1 eigenvector of sigma_x)\n\"i\" (aliases: \"Y+\", \"Yp\") Qubit in the irangle state (+1 eigenvector of sigma_y)\n\"-i\" (aliases: \"Y-\", \"Ym\") Qubit in the -irangle state (+1 eigenvector of sigma_y)","category":"page"},{"location":"IncludedSiteTypes.html#\"Qubit\"-and-\"S1/2\"-Operators","page":"SiteTypes Included with ITensor","title":"\"Qubit\" and \"S=1/2\" Operators","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Operators or gates associated with \"Qubit\" sites can be made using the op function, for example","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"H = op(\"H\",s)\nH3 = op(\"H\",sites[3])","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Single-qubit operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"X\" (aliases: \"σx\", \"σ1\") Pauli X operator\n\"Y\" (aliases: \"σy\", \"σ2\") Pauli Y operator\n\"iY\" (aliases: \"iσy\", \"iσ2\") Pauli Y operator times i\n\"Z\" (aliases: \"σz\", \"σ3\") Pauli Z operator\n\"√NOT\" (aliases: \"X\")\n\"H\" Hadamard gate\n\"Phase\" (takes optional argument: ϕ=π/2) (aliases: \"P\", \"S\")\n\"π/8\" (aliases: \"T\")\n\"Rx\" (takes argument: θ) Rotation around x axis\n\"Ry\" (takes argument: θ) Rotation around y axis\n\"Rz\" (takes argument: θ) Rotation around z axis\n\"Rn\" (takes arguments: θ, ϕ, λ) (aliases: \"Rn̂\") Rotation about axis n=(θ, ϕ, λ)\n\"Proj0\" (aliases: \"ProjUp\", \"projUp\") Operator 0ranglelangle 0\n\"Proj1\" (aliases: \"ProjDn\", \"projDn\") Operator 1ranglelangle 1","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Spin operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Sz\" (aliases: \"Sᶻ\") Spin z operator S^z = frac12 sigma_z\n\"S+\" (alises: \"S⁺\", \"Splus\") Raising operator S^+ = S^x + iS^y\n\"S-\" (aliases: \"S⁻\", \"Sminus\") Lowering operator S^- = S^x - iS^y\n\"Sx\" (alises: \"Sˣ\") Spin x operator S^x = frac12 sigma_x\n\"iSy\" (aliases: \"iSʸ\") i times spin y operator iS^y = fraci2 sigma_y\n\"Sy\" (aliases: \"Sʸ\") Spin y operator S^y = frac12 sigma_y\n\"S2\" (aliases: \"S²\"`) Square of spin vector operator S^2=vecScdotvecS=frac34 I\n\"ProjUp\" (aliases: \"projUp\", \"Proj0\") Operator ranglelangle \n\"ProjDn\" (aliases: \"projDn\", \"Proj1\") Operator ranglelangle ","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Two-qubit gates:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"CNOT\" (aliases: \"CX\") Controlled NOT gate\n\"CY\" Controlled Y gate\n\"CZ\" Controlled Z gate\n\"CPHASE\" (aliases: \"Cphase\") Controlled Phase gate\n\"CRx\" (aliases: \"CRX\") (takes arguments: θ)\n\"CRy\" (aliases: \"CRY\") (takes arguments: θ)\n\"CRz\" (aliases: \"CRZ\") (takes arguments: θ)\n\"CRn\" (aliases: \"CRn̂\") (takes arguments: θ, ϕ, λ)\n\"SWAP\" (aliases: \"Swap\")\n\"√SWAP\" (aliases: \"√Swap\")\n\"iSWAP\" (aliases: \"iSwap\")\n\"√iSWAP\" (aliases: \"√iSwap\")\n\"Rxx\" (aliases: \"RXX\") (takes arguments: ϕ) Ising (XX) coupling gate\n\"Ryy\" (aliases: \"RYY\") (takes arguments: ϕ) Ising (YY) coupling gate\n\"Rzz\" (aliases: \"RZZ\") (takes arguments: ϕ) Ising (ZZ) coupling gate","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Three-qubit gates:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Toffoli\" (aliases \"CCNOT\", \"CCX\", \"TOFF\")\n\"Fredkin\" (aliases \"CSWAP\", \"CSwap\", \"CS\")","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Four-qubit gates:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"CCCNOT\"","category":"page"},{"location":"IncludedSiteTypes.html#\"S1\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"S=1\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Site indices with the \"S=1\" site type represent S=1 spins with the states uparrowrangle, 0rangle, downarrowrangle.","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Making a single \"S=1\" site or collection of N \"S=1\" sites","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"s = siteind(\"S=1\")\nsites = siteinds(\"S=1\",N)","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"conserve_qns (default: false): conserve total S^z\nconserve_sz (default: conserve_qns): conserve total S^z\nqnname_sz (default: \"Sz\"): name of total S^z QN","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"For example:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"sites = siteinds(\"S=1\",N; conserve_sz=true, qnname_sz=\"TotalSz\")","category":"page"},{"location":"IncludedSiteTypes.html#\"S1\"-States","page":"SiteTypes Included with ITensor","title":"\"S=1\" States","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"The available state names for \"S=1\" sites are:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Up\" (aliases: \"Z+\", \"↑\") spin in the up state\n\"Z0\" (aliases: \"0\") spin in the Sz=0 state\n\"Dn\" (aliases: \"Z-\", \"↓\") spin in the down state","category":"page"},{"location":"IncludedSiteTypes.html#\"S1\"-Operators","page":"SiteTypes Included with ITensor","title":"\"S=1\" Operators","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Operators associated with \"S=1\" sites can be made using the op function, for example","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Sz = op(\"Sz\",s)\nSz4 = op(\"Sz\",sites[4])","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Spin operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Sz\" (aliases: \"Sᶻ\")\n\"Sz2\" Square of S^z operator\n\"S+\" (alises: \"S⁺\", \"Splus\")\n\"S-\" (aliases: \"S⁻\", \"Sminus\")\n\"Sx\" (alises: \"Sˣ\")\n\"Sx2\" Square of S^x operator\n\"iSy\" (aliases: \"iSʸ\")\n\"Sy\" (aliases: \"Sʸ\")\n\"Sy2\" Square of S^y operator\n\"S2\" (aliases: \"S²\"`)","category":"page"},{"location":"IncludedSiteTypes.html#\"Boson\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"Boson\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"The \"Boson\" site type is an alias for the \"Qudit\" site type. Please see more information about \"Qudit\" below:","category":"page"},{"location":"IncludedSiteTypes.html#\"Qudit\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"Qudit\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Making a single \"Qudit\" site or collection of N \"Qudit\" sites","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"s = siteind(\"Qudit\")\nsites = siteinds(\"Qudit\",N)","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"dim (default: 2): dimension of the index (number of qudit or boson values)\nconserve_qns (default: false): conserve total qudit or boson number\nconserve_number (default: conserve_qns): conserve total qudit or boson number\nqnname_number (default: \"Number\"): name of total qudit or boson number QN","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"For example:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"sites = siteinds(\"Qudit\",N; conserve_number=true)","category":"page"},{"location":"IncludedSiteTypes.html#\"Qudit\"-and-\"Boson\"-Operators","page":"SiteTypes Included with ITensor","title":"\"Qudit\" and \"Boson\" Operators","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Operators associated with \"Qudit\" sites can be made using the op function, for example","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"A = op(\"A\",s)\nA4 = op(\"A\",sites[4])","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Single-qudit operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"A\" (aliases: \"a\")\n\"Adag\" (aliases: \"adag\", \"a†\")\n\"N\" (aliases: \"n\")","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Two-qudit operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"ab\"\n\"a†b\"\n\"ab†\"\n\"a†b†\"","category":"page"},{"location":"IncludedSiteTypes.html#\"Fermion\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"Fermion\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Site indices with the \"Fermion\" SiteType represent spinless fermion sites with the states 0rangle, 1rangle, corresponding to zero fermions or one fermion.","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Making a single \"Fermion\" site or collection of N \"Fermion\" sites","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"s = siteind(\"Fermion\")\nsites = siteinds(\"Fermion\",N)","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"conserve_qns (default: false): conserve total number of fermions\nconserve_nf (default: conserve_qns): conserve total number of fermions\nconserve_nfparity (default: conserve_qns): conserve total fermion number parity\nqnname_nf (default: \"Nf\"): name of total fermion number QN\nqnname_nfparity (default: \"NfParity\"): name of total fermion number parity QN","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"For example:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"sites = siteinds(\"Fermion\",N; conserve_nfparity=true)","category":"page"},{"location":"IncludedSiteTypes.html#\"Fermion\"-States","page":"SiteTypes Included with ITensor","title":"\"Fermion\" States","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"The available state names for \"Fermion\" sites are:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"0\" (aliases: \"Emp\") unoccupied fermion site\n\"1\" (aliases: \"Occ\") occupied fermion site","category":"page"},{"location":"IncludedSiteTypes.html#\"Fermion\"-Operators","page":"SiteTypes Included with ITensor","title":"\"Fermion\" Operators","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Operators associated with \"Fermion\" sites can be made using the op function, for example","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"C = op(\"C\",s)\nC4 = op(\"C\",sites[4])","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Single-fermion operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"N\" (aliases: \"n\") Density operator\n\"C\" (aliases: \"c\") Fermion annihilation operator\n\"Cdag\" (aliases: \"cdag\", \"c†\") Fermion creation operator\n\"F\" Jordan-Wigner string operator","category":"page"},{"location":"IncludedSiteTypes.html#\"Electron\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"Electron\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"The states of site indices with the \"Electron\" SiteType correspond to 0rangle, uparrowrangle, downarrowrangle, uparrowdownarrowrangle.","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Making a single \"Electron\" site or collection of N \"Electron\" sites","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"s = siteind(\"Electron\")\nsites = siteinds(\"Electron\",N)","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"conserve_qns (default: false): conserve total number of electrons\nconserve_sz (default: conserve_qns): conserve total S^z\nconserve_nf (default: conserve_qns): conserve total number of electrons\nconserve_nfparity (default: conserve_qns): conserve total electron number parity\nqnname_sz (default: \"Sz\"): name of total S^z QN\nqnname_nf (default: \"Nf\"): name of total electron number QN\nqnname_nfparity (default: \"NfParity\"): name of total electron number parity QN","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"For example:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"sites = siteinds(\"Electron\",N; conserve_nfparity=true)","category":"page"},{"location":"IncludedSiteTypes.html#\"Electron\"-States","page":"SiteTypes Included with ITensor","title":"\"Electron\" States","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"The available state names for \"Electron\" sites are:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Emp\" (aliases: \"0\") unoccupied electron site\n\"Up\" (aliases: \"↑\") electron site occupied with one up electron\n\"Dn\" (aliases: \"↓\") electron site occupied with one down electron\n\"UpDn\" (aliases: \"↑↓\") electron site occupied with two electrons (one up, one down)","category":"page"},{"location":"IncludedSiteTypes.html#\"Electron\"-Operators","page":"SiteTypes Included with ITensor","title":"\"Electron\" Operators","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Operators associated with \"Electron\" sites can be made using the op function, for example","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Cup = op(\"Cup\",s)\nCup4 = op(\"Cup\",sites[4])","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Single-fermion operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Ntot\" (aliases: \"ntot\") Total density operator\n\"Nup\" (aliases: \"n↑\") Up density operator\n\"Ndn\" (aliases: \"n↓\") Down density operator\n\"Cup\" (aliases: \"c↑\") Up-spin annihilation operator\n\"Cdn\" (aliases: \"c↓\") Down-spin annihilation operator\n\"Cdagup\" (aliases: \"c†↑\") Up-spin creation operator\n\"Cdagdn\" (aliases: \"c†↓\") Down-spin creation operator\n\"Sz\" (aliases: \"Sᶻ\")\n\"Sx\" (aliases: \"Sˣ\")\n\"S+\" (aliases: \"Sp\", \"S⁺\",\"Splus\")\n\"S-\" (aliases: \"Sm\", \"S⁻\", \"Sminus\")\n\"F\" Jordan-Wigner string operator\n\"Fup\" (aliases: \"F↑\") Up-spin Jordan-Wigner string operator\n\"Fdn\" (aliases: \"F↓\") Down-spin Jordan-Wigner string operator","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Non-fermionic single particle operators (these do not have Jordan-Wigner string attached, so will commute within systems such as OpSum or the apply function):","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Aup\" (aliases: \"a↑\") Up-spin annihilation operator\n\"Adn\" (aliases: \"a↓\") Down-spin annihilation operator\n\"Adagup\" (aliases: \"a†↑\") Up-spin creation operator\n\"Adagdn\" (aliases: \"a†↓\") Down-spin creation operator","category":"page"},{"location":"IncludedSiteTypes.html#\"tJ\"-SiteType","page":"SiteTypes Included with ITensor","title":"\"tJ\" SiteType","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"tJ\" sites are similar to electron sites, but cannot be doubly occupied The states of site indices with the \"tJ\" SiteType correspond to 0rangle, uparrowrangle, downarrowrangle.","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Making a single \"tJ\" site or collection of N \"tJ\" sites","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"s = siteind(\"tJ\")\nsites = siteinds(\"tJ\",N)","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"conserve_qns (default: false): conserve total number of fermions\nconserve_nf (default: conserve_qns): conserve total number of fermions\nconserve_nfparity (default: conserve_qns): conserve total fermion number parity\nqnname_nf (default: \"Nf\"): name of total fermion number QN\nqnname_nfparity (default: \"NfParity\"): name of total fermion number parity QN","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"For example:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"sites = siteinds(\"tJ\",N; conserve_nfparity=true)","category":"page"},{"location":"IncludedSiteTypes.html#\"tJ\"-States","page":"SiteTypes Included with ITensor","title":"\"tJ\" States","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"The available state names for \"tJ\" sites are:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Emp\" (aliases: \"0\") unoccupied site\n\"Up\" (aliases: \"↑\") site occupied with one up electron\n\"Dn\" (aliases: \"↓\") site occupied with one down electron","category":"page"},{"location":"IncludedSiteTypes.html#\"tJ\"-Operators","page":"SiteTypes Included with ITensor","title":"\"tJ\" Operators","text":"","category":"section"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Operators associated with \"tJ\" sites can be made using the op function, for example","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Cup = op(\"Cup\",s)\nCup4 = op(\"Cup\",sites[4])","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Single-fermion operators:","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Ntot\" (aliases: \"ntot\") Total density operator\n\"Nup\" (aliases: \"n↑\") Up density operator\n\"Ndn\" (aliases: \"n↓\") Down density operator\n\"Cup\" (aliases: \"c↑\") Up-spin annihilation operator\n\"Cdn\" (aliases: \"c↓\") Down-spin annihilation operator\n\"Cdagup\" (aliases: \"c†↑\") Up-spin creation operator\n\"Cdagdn\" (aliases: \"c†↓\") Down-spin creation operator\n\"Sz\" (aliases: \"Sᶻ\")\n\"Sx\" (aliases: \"Sˣ\")\n\"S+\" (aliases: \"Sp\", \"S⁺\",\"Splus\")\n\"S-\" (aliases: \"Sm\", \"S⁻\", \"Sminus\")\n\"F\" Jordan-Wigner string operator\n\"Fup\" (aliases: \"F↑\") Up-spin Jordan-Wigner string operator\n\"Fdn\" (aliases: \"F↓\") Down-spin Jordan-Wigner string operator","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"Non-fermionic single particle operators (these do not have Jordan-Wigner string attached, so will commute within systems such as OpSum or the apply function):","category":"page"},{"location":"IncludedSiteTypes.html","page":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","text":"\"Aup\" (aliases: \"a↑\") Up-spin annihilation operator\n\"Adn\" (aliases: \"a↓\") Down-spin annihilation operator\n\"Adagup\" (aliases: \"a†↑\") Up-spin creation operator\n\"Adagdn\" (aliases: \"a†↓\") Down-spin creation operator","category":"page"},{"location":"Sweeps.html#Sweeps","page":"Sweeps","title":"Sweeps","text":"","category":"section"},{"location":"Sweeps.html","page":"Sweeps","title":"Sweeps","text":"Sweeps\nSweeps(nsw::Int, d::AbstractMatrix)","category":"page"},{"location":"Sweeps.html#ITensorMPS.Sweeps","page":"Sweeps","title":"ITensorMPS.Sweeps","text":"A Sweeps objects holds information about the various parameters controlling a density matrix renormalization group (DMRG) or similar matrix product state (MPS) calculation.\n\nFor a Sweeps object sw the available parameters are:\n\nnsweep(sw) – the number of sweeps to do\nmaxdim(sw,n) – maximum MPS bond dimension for sweep n\nmindim(sw,n) – minimum MPS bond dimension for sweep n\ncutoff(sw,n) – truncation error cutoff for sweep n\nnoise(sw,n) – noise term coefficient for sweep n\n\n\n\n\n\n","category":"type"},{"location":"Sweeps.html#ITensorMPS.Sweeps-Tuple{Int64, AbstractMatrix}","page":"Sweeps","title":"ITensorMPS.Sweeps","text":"Sweeps(d::AbstractMatrix)\n\nSweeps(nsweep::Int, d::AbstractMatrix)\n\nMake a sweeps object from a matrix of input values. The first row should be strings that define which variables are being set (\"maxdim\", \"cutoff\", \"mindim\", and \"noise\").\n\nIf the number of sweeps are not specified, they are determined from the size of the input matrix.\n\nExamples\n\njulia > Sweeps(\n  [\n    \"maxdim\" \"mindim\" \"cutoff\" \"noise\"\n    50 10 1e-12 1E-7\n    100 20 1e-12 1E-8\n    200 20 1e-12 1E-10\n    400 20 1e-12 0\n    800 20 1e-12 1E-11\n    800 20 1e-12 0\n  ],\n)\nSweeps\n1cutoff = 1.0E-12, maxdim = 50, mindim = 10, noise = 1.0E-07\n2cutoff = 1.0E-12, maxdim = 100, mindim = 20, noise = 1.0E-08\n3cutoff = 1.0E-12, maxdim = 200, mindim = 20, noise = 1.0E-10\n4cutoff = 1.0E-12, maxdim = 400, mindim = 20, noise = 0.0E+00\n5cutoff = 1.0E-12, maxdim = 800, mindim = 20, noise = 1.0E-11\n6cutoff = 1.0E-12, maxdim = 800, mindim = 20, noise = 0.0E+00\n\n\n\n\n\n","category":"method"},{"location":"Sweeps.html#Modifying-Sweeps-Objects","page":"Sweeps","title":"Modifying Sweeps Objects","text":"","category":"section"},{"location":"Sweeps.html","page":"Sweeps","title":"Sweeps","text":"setmaxdim!\nsetcutoff!\nsetnoise!\nsetmindim!","category":"page"},{"location":"Sweeps.html#ITensorMPS.setmaxdim!","page":"Sweeps","title":"ITensorMPS.setmaxdim!","text":"maxdim!(sw::Sweeps,maxdims::Int...)\n\nSet the maximum MPS bond dimension for each sweep by providing up to nsweep(sw) values. If fewer values are provided, the last value is repeated for the remaining sweeps.\n\n\n\n\n\n","category":"function"},{"location":"Sweeps.html#ITensorMPS.setcutoff!","page":"Sweeps","title":"ITensorMPS.setcutoff!","text":"cutoff!(sw::Sweeps,maxdims::Int...)\n\nSet the MPS truncation error used for each sweep by providing up to nsweep(sw) values. If fewer values are provided, the last value is repeated for the remaining sweeps.\n\n\n\n\n\n","category":"function"},{"location":"Sweeps.html#ITensorMPS.setnoise!","page":"Sweeps","title":"ITensorMPS.setnoise!","text":"noise!(sw::Sweeps,maxdims::Int...)\n\nSet the noise-term coefficient used for each sweep by providing up to nsweep(sw) values. If fewer values are provided, the last value is repeated for the remaining sweeps.\n\n\n\n\n\n","category":"function"},{"location":"Sweeps.html#ITensorMPS.setmindim!","page":"Sweeps","title":"ITensorMPS.setmindim!","text":"mindim!(sw::Sweeps,maxdims::Int...)\n\nSet the minimum MPS bond dimension for each sweep by providing up to nsweep(sw) values. If fewer values are provided, the last value is repeated for the remaining sweeps.\n\n\n\n\n\n","category":"function"},{"location":"Sweeps.html#Getting-Sweeps-Object-Data","page":"Sweeps","title":"Getting Sweeps Object Data","text":"","category":"section"},{"location":"Sweeps.html","page":"Sweeps","title":"Sweeps","text":"nsweep(sw::Sweeps)\nmaxdim(sw::Sweeps,n::Int)\ncutoff(sw::Sweeps,n::Int)\nnoise(sw::Sweeps,n::Int)\nmindim(sw::Sweeps,n::Int)","category":"page"},{"location":"Sweeps.html#ITensorMPS.nsweep-Tuple{Sweeps}","page":"Sweeps","title":"ITensorMPS.nsweep","text":"nsweep(sw::Sweeps)\nlength(sw::Sweeps)\n\nObtain the number of sweeps parameterized by this sweeps object.\n\n\n\n\n\n","category":"method"},{"location":"Sweeps.html#NDTensors.maxdim-Tuple{Sweeps, Int64}","page":"Sweeps","title":"NDTensors.maxdim","text":"maxdim(sw::Sweeps,n::Int)\n\nMaximum MPS bond dimension allowed by the Sweeps object sw during sweep n\n\n\n\n\n\n","category":"method"},{"location":"Sweeps.html#ITensorMPS.cutoff-Tuple{Sweeps, Int64}","page":"Sweeps","title":"ITensorMPS.cutoff","text":"cutoff(sw::Sweeps,n::Int)\n\nTruncation error cutoff setting of the Sweeps object sw during sweep n\n\n\n\n\n\n","category":"method"},{"location":"Sweeps.html#ITensorMPS.noise-Tuple{Sweeps, Int64}","page":"Sweeps","title":"ITensorMPS.noise","text":"noise(sw::Sweeps,n::Int)\n\nNoise term coefficient setting of the Sweeps object sw during sweep n\n\n\n\n\n\n","category":"method"},{"location":"Sweeps.html#NDTensors.mindim-Tuple{Sweeps, Int64}","page":"Sweeps","title":"NDTensors.mindim","text":"mindim(sw::Sweeps,n::Int)\n\nMinimum MPS bond dimension allowed by the Sweeps object sw during sweep n\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"Home","title":"Home","text":"EditURL = \"../../examples/README.jl\"","category":"page"},{"location":"index.html#ITensorMPS.jl","page":"Home","title":"ITensorMPS.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Finite MPS and MPO methods based on the Julia version of ITensor (ITensors.jl). See the ITensorMPS.jl documentation for more details.","category":"page"},{"location":"index.html#Support","page":"Home","title":"Support","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"<img src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\">","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ITensorMPS.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"page"},{"location":"index.html#News","page":"Home","title":"News","text":"","category":"section"},{"location":"index.html#ITensorMPS.jl-v0.3-release-notes","page":"Home","title":"ITensorMPS.jl v0.3 release notes","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"All MPS/MPO code from ITensors.jl and ITensorTDVP.jl has been moved into this repository and this repository now relies on ITensors.jl v0.7 and above. All of the MPS/MPO functionality that was previously in ITensors.jl and ITensorTDVP.jl will be developed here from now on. For users of this repository, this change should not break any code, though please let us know if you have any issues.","category":"page"},{"location":"index.html#Upgrade-guide","page":"Home","title":"Upgrade guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you are using any MPS/MPO functionality of ITensors.jl, such as the MPS and MPO types or constructors thereof (like random_mps), OpSum, siteinds, dmrg, apply, etc. you should install the ITensorMPS.jl package with import Pkg; Pkg.add(\"ITensorMPS\") and add using ITensorMPS to your code. Additionally, if you are currently using ITensorTDVP.jl, you should replace using ITensorTDVP with using ITensorMPS in your code.","category":"page"},{"location":"index.html#ITensorMPS.jl-v0.2.1-release-notes","page":"Home","title":"ITensorMPS.jl v0.2.1 release notes","text":"","category":"section"},{"location":"index.html#New-features","page":"Home","title":"New features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This release introduces a new (experimental) function expand for performing global Krylov expansion based on arXiv:2005.06104. It is a re-export of the expand function introduced in ITensorTDVP.jl v0.4.1, see the ITensorTDVP.jl v0.4.1 release notes for more details.","category":"page"},{"location":"index.html#ITensorMPS.jl-v0.2-release-notes","page":"Home","title":"ITensorMPS.jl v0.2 release notes","text":"","category":"section"},{"location":"index.html#Breaking-changes","page":"Home","title":"Breaking changes","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ITensorMPS.jl v0.2 has been released, which is a breaking release. It updates to using ITensorTDVP.jl v0.4, which has a number of breaking changes to the tdvp, linsolve, and dmrg_x functions. See the ITensorTDVP.jl v0.4 release notes for details.","category":"page"},{"location":"index.html#Example-DMRG-Calculation","page":"Home","title":"Example DMRG Calculation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DMRG is an iterative algorithm for finding the dominant eigenvector of an exponentially large, Hermitian matrix. It originates in physics with the purpose of finding eigenvectors of Hamiltonian (energy) matrices which model the behavior of quantum systems.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using ITensors, ITensorMPS\nlet\n  # Create 100 spin-one indices\n  N = 100\n  sites = siteinds(\"S=1\", N)\n\n  # Input operator terms which define\n  # a Hamiltonian matrix, and convert\n  # these terms to an MPO tensor network\n  # (here we make the 1D Heisenberg model)\n  os = OpSum()\n  for j in 1:(N - 1)\n    os += \"Sz\", j, \"Sz\", j + 1\n    os += 0.5, \"S+\", j, \"S-\", j + 1\n    os += 0.5, \"S-\", j, \"S+\", j + 1\n  end\n  H = MPO(os, sites)\n\n  # Create an initial random matrix product state\n  psi0 = random_mps(sites)\n\n  # Plan to do 5 passes or 'sweeps' of DMRG,\n  # setting maximum MPS internal dimensions\n  # for each sweep and maximum truncation cutoff\n  # used when adapting internal dimensions:\n  nsweeps = 5\n  maxdim = [10, 20, 100, 100, 200]\n  cutoff = 1E-10\n\n  # Run the DMRG algorithm, returning energy\n  # (dominant eigenvalue) and optimized MPS\n  energy, psi = dmrg(H, psi0; nsweeps, maxdim, cutoff)\n  println(\"Final energy = $energy\")\n\n  nothing\nend\n\n# output\n\n# After sweep 1 energy=-137.954199761732 maxlinkdim=9 maxerr=2.43E-16 time=9.356\n# After sweep 2 energy=-138.935058943878 maxlinkdim=20 maxerr=4.97E-06 time=0.671\n# After sweep 3 energy=-138.940080155429 maxlinkdim=92 maxerr=1.00E-10 time=4.522\n# After sweep 4 energy=-138.940086009318 maxlinkdim=100 maxerr=1.05E-10 time=11.644\n# After sweep 5 energy=-138.940086058840 maxlinkdim=96 maxerr=1.00E-10 time=12.771\n# Final energy = -138.94008605883985","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can find more examples of running dmrg and related algorithms here.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"},{"location":"faq/DMRG.html#Density-Matrix-Renormalization-Group-(DMRG)-Frequently-Asked-Questions","page":"DMRG FAQs","title":"Density Matrix Renormalization Group (DMRG) Frequently Asked Questions","text":"","category":"section"},{"location":"faq/DMRG.html#Ensuring-a-DMRG-calculation-is-converged","page":"DMRG FAQs","title":"Ensuring a DMRG calculation is converged","text":"","category":"section"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"While DMRG calculations can be extremely quick to converge in the best cases, convergence can be slower for cases such as gapless systems or quasi-two-dimensional systems. So it becomes important to know if a DMRG calculation is converged i.e. has been run long enough with enough resources (large enough MPS bond dimension).","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Unfortunately there is no automatic or bulletproof check for DMRG convergence. However, there are a number of reliable heuristics you can use to check convergence. We list some of these with the most fundamental and important ones first:","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Run your DMRG calculation on a smaller system and compare with another method, such as an exact diagonalization. If the agreement is good, then gradually try larger systems and see if the physical properties are roughly consistent and similar (i.e. the density profile has similar features).\nMake sure to check a wide range of properties - not just the energy. See if these look plausible by plotting and visually inspecting them. For example: if your system has left-right reflection symmetry, does the density or magnetization also have this symmetry? If the ground  state of your system is expected to have a total S^z of zero, does your ground state have this property?\nMake sure to run your DMRG calculation for different numbers of sweeps to see if the results change. For example, if you run DMRG for 5 sweeps but are unsure of convergence, try running it for 10 sweeps: is the energy the same or has it significantly decreased? If 10 sweeps made a difference, try 20 sweeps.\nTry setting the eigsolve_krylovdim keyword argument to a higher value (the default is 3). This can be particularily helpful when the Hamiltonian is close to a critical point. This may make slowly-converging calculations converge in fewer sweeps, but setting it too high can make each sweep run slowly.\nInspect the the DMRG output. The ITensor DMRG code reports the maximum bond or link dimension and maximum truncation error after each sweep. (The maximums here mean over each DMRG substep making up one sweep.) Is the maximum dimension or \"maxlinkdim\" reported by the DMRG output quickly reaching and saturating the maxdim value you set for each sweep? Is the maximum truncation error \"maxerr\" consistently reaching large values, larger than 1E-5? Then it you may need to raise the maxdim parameter for your later sweeps, so that DMRG is allowed to use a larger bond dimension and thus reach a better accuracy.\nCompute the energy variance of an MPS to check whether it is an eigenstate. To do this in ITensor, you can use the following code where H is your Hamiltonian MPO and psi is the wavefunction you want to check:\nH2 = inner(H,psi,H,psi)\nE = inner(psi',H,psi)\nvar = H2-E^2\n@show var\nHere var is the quantity langle H^2 rangle - langle H rangle^2. The closer var is to zero, the more precisely psi is an eigenstate of H. Note that this check does not ensure that psi is the ground state, but only one of the eigenstates.","category":"page"},{"location":"faq/DMRG.html#Preventing-DMRG-from-getting-stuck-in-a-local-minimum","page":"DMRG FAQs","title":"Preventing DMRG from getting stuck in a local minimum","text":"","category":"section"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"While DMRG has very robust convergence properties when the initial MPS is close to the global minimum, if it is far from the global minumum then there is no guarantee that DMRG will be able to find the true ground state. This problem is exacerbated for quantum number conserving DMRG where the search space is more constrained.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Thus it is very important to perform a number of checks to ensure that the result you get from DMRG is actually converged. To learn about these checks, see the previous question.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"When DMRG is failing to converge, here are some of the steps you can take to improve things:","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"The most important and useful technique is to turn on the noise term feature of DMRG. To do this, just set the noise parameter of each sweep to a small, non-zero value, making this value very small (1E-11, say) or zero by the last sweep. (Experiment with different values on small systems to see which noise magnitudes help.) Here is an example of defining DMRG accuracy or sweep parameters with a non-zero noise set for the first three sweeps:\nnsweeps = 10\nmaxdim = [100, 200, 400, 800, 1600]\ncutoff = [1E-6]\nnoise = [1E-6, 1E-7, 1E-8, 0.0]\n...\nenergy, psi = dmrg(H,psi0; nsweeps, maxdim, cutoff, noise)\nTry using a initial MPS with properties close to the ground state you are looking for. For example, the ground state of a system of electrons typically has a density which is spread out over the whole system. So if your initial state has all of the electrons bunched up on the left-hand side only, it can take DMRG a very long time to converge.\nTry using a random MPS with a modestly large bond dimension. ITensor offers a function called random_mps which can be used to make random MPS in both the quantum number (QN) conserving and non-QN conserving cases. Because random MPS have properties which are \"typical\" of most ground states, they can be good initial states for DMRG.\nTry DMRG on a closely related Hamiltonian for which convergence is easier to obtain (be creative here: it could be your Hamiltonian with interactions turned off, or  with interactions only within, but not between, small local patches). Take the output of this first calculation and use it as input for DMRG with the full Hamiltonian.\nIn stubborn cases, try other methods for finding the ground state which are slower, but have a better chance of succeeding. A key example is imaginary time evolution, which always reaches the ground state if (a) performed accurately on (b) a state which is not orthogonal to the ground state. After doing some amount of imaginary time evolution, use the resulting MPS as an initial state for DMRG obtain a higher-accuracy solution.","category":"page"},{"location":"faq/DMRG.html#How-to-do-periodic-boundary-condition-DMRG","page":"DMRG FAQs","title":"How to do periodic boundary condition DMRG","text":"","category":"section"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"The short answer to how to do fully periodic boundary condition DMRG in ITensor is that you simply input a periodic Hamiltonian into our OpSum system and make the MPO form of your Hamiltonian in the usual way. For example, for a chain of N sites with nearest-neighbor interactions, you include a term that connects site 1 to site N. For a one-dimensional Ising model chain Hamiltonian this would look like:","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"sites = siteinds(\"S=1/2\",N)\n\nhterms = OpSum()\nfor j=1:(N-1)\n  hterms += \"Sz\",j,\"Sz\",j+1\nend\nhterms += \"Sz\",1,\"Sz\",N  # term 'wrapping' around the ring\n\nH = MPO(hterms,sites)","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"For two-dimensional DMRG calculations, where the most common approach is to use periodic boundary conditions in the y-direction only, and not in the x-direction, you do a similar step in making your OpSum input to ITensor DMRG: you include terms wrapping around the periodic cylinder in the y direction but not in the x direction.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"However, fully periodic boundary conditions are only recommended for small systems when absolutely needed, and in general are not recommended. For a longer discussion of alternatives to using fully periodic boundaries, see the next section below.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"The reason fully periodic boundary conditions (periodic in x in 1D, and periodic in both x and y in 2D) are not recommended in general is that the DMRG algorithm, as we are defining it here, optimizes an open-boundary MPS. So if you input a periodic-boundary Hamiltonian, there is a kind of \"mismatch\" that happens where you can still get the correct answer, but it requires much more resources (a larger bond dimension and more sweeps) to get good accuracy. There has been some research into \"truly\" periodic DMRG, [Pippan] that is DMRG that optimizes an MPS with a ring-like topology, but it is not widely used, is still an open area of algorithm development, and is not currently available in ITensor.","category":"page"},{"location":"faq/DMRG.html#What-boundary-conditions-should-I-choose:-open,-periodic,-or-infinite?","page":"DMRG FAQs","title":"What boundary conditions should I choose: open, periodic, or infinite?","text":"","category":"section"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"One of the weaknesses of the density matrix renormalization group (DMRG), and its time-dependent or finite-temperature extensions, is that it works poorly with periodic boundary conditions. This stems from the fact that conventional DMRG optimizes over open-boundary matrix product state (MPS) wavefunctions whether or not the Hamiltonian includes periodic interactions.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"But this begs the question, when are periodic boundary conditions (PBC) really needed? DMRG offers some compelling alternatives to PBC:","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Use open boundary conditions (OBC). Though this introduces edge effects, the number of states needed to reach a given accuracy is significantly lower than with PBC (see next section below). For gapped systems DMRG scales linearly with system size, meaning often one can study systems with many hundreds or even thousands of sites. Last but not least, open boundaries are often more natural. For studying systems which spontaneously break symmetry, adding \"pinning\" fields on the edge is often a very nice way to tip the balance toward a certain symmetry broken state while leaving the bulk unmodified.\nUse smooth boundary conditions. The basic idea is to use OBC but send the Hamiltonian parameters smoothly to zero at the boundary so that the system can not \"feel\" the boundary. For certain systems this can significantly reduce edge effects.[Smooth1][Smooth2][Smooth3]","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Smooth1]: Smooth boundary conditions for quantum lattice systems, M. Vekic and Steven R. White, Phys. Rev. Lett. 71, 4283 (1993) cond-mat/9310053","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Smooth2]: Hubbard model with smooth boundary conditions, M. Vekic and Steven R. White, Phys. Rev. B 53, 14552 (1996) cond-mat/9601009","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Smooth3]: Grand canonical finite-size numerical approaches: A route to measuring bulk properties in an applied field, Chisa Hotta and Naokazu Shibata, Phys. Rev. B 86, 041108 (2012)","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Use \"infinite boundary conditions\", that is, use infinite DMRG in the form of an algorithm like iDMRG or VUMPS. This has a cost that can be even less than with OBC yet is completely free of finite-size effects.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"However, there are a handful of cases where PBC remains preferable despite the extra overhead. A few such cases are:","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Benchmarking DMRG against another code that uses PBC, such as a Monte Carlo or exact diagonalization code.\nExtracting the central charge of a critical one-dimensional system described by a CFT. In practice, using PBC can give an accurate central charge even for quite small systems by fitting the subsystem entanglement entropy to the CFT scaling form.\nChecking for the presence or absence of topological effects. These could be edge effects (the Haldane phase has a four-fold ground state degeneracy with OBC, but not with PBC), or could be related to some global topological sector that is ill-defined with PBC (e.g. periodic vs. antiperiodic boundary conditions for the transverse field Ising model).","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"(Note that in the remaining discussion, by PBC I mean  fully periodic boundary conditions in all directions. For the case of DMRG applied to quasi-two-dimensional systems, it remains a good practice to use periodic boundaries in the shorter direction, while still using open (or infinite) boundaries in the longer direction along the DMRG/MPS path.)","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Below I discuss more about the problems with using PBC, as well as some misconceptions about when PBC seems necessary even though there are better alternatives.","category":"page"},{"location":"faq/DMRG.html#Drawbacks-of-Periodic-Boundary-Conditions","page":"DMRG FAQs","title":"Drawbacks of Periodic Boundary Conditions","text":"","category":"section"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Periodic boundary conditions are straightforward to implement in conventional DMRG. The simplest approach is to include a \"long bond\" directly connecting site 1 to site N in the Hamiltonian. However this naive approach has a major drawback: if open-boundary DMRG achieves a given accuracy when keeping m states (bond dimension of size m), then to reach the same accuracy with PBC one must keep closer to m^2 states! The reason is that now every bond of the MPS not only carries local entanglement as with OBC, but also the entanglement between the first and last sites. (There is an alternative DMRG algorithm[Pippan] for periodic systems which may have better scaling than the above approach but has not been widely applied and tested, as far as I am aware, especially for  2D or critical systems .)","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Pippan]: Efficient matrix-product state method for periodic boundary conditions, P. Pippan, Steven R. White, and H.G. Evertz, Phys. Rev. B 81, 081103","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"The change in scaling from m to m^2  is a severe problem. For example, many gapped one-dimensional systems only require about m=100 to reach good accuracy (truncation errors of less than 1E-9 or so). To reach the same accuracy with naive PBC would then require using 10,000 states, which can easily fill the RAM of a typical desktop computer for a large enough system, not to mention the extra time needed to work with larger matrices.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"But poor scaling is not the only drawback of PBC. Systems that exhibit spontaneous symmetry breaking are simple to work with under OBC, where one has the additional freedom of applying edge pinning terms to drive the bulk into a specific symmetry sector. Using edge pinning reduces the bulk entanglement and makes measuring order parameters straightforward. Similarly one can use infinite DMRG to directly observe symmetry breaking effects.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"But under PBC, order parameters remain equal to zero and can only be accessed through correlation functions. Though using correlation functions is often presented as the \"standard\" or \"correct\" approach, such reasoning pre-supposes that PBC is the best choice. Recent work in the quantum Monte Carlo community demonstrates that open boundaries with pinning fields can actually be a superior approach.[Assaad]","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Assaad]: Pinning the Order: The Nature of Quantum Criticality in the Hubbard Model on Honeycomb Lattice, Fakher F. Assaad and Igor F. Herbut, Phys. Rev. X 3, 031010","category":"page"},{"location":"faq/DMRG.html#Cases-Where-Periodic-BC-Seems-Necessary,-But-Open/Infinite-BC-Can-be-Better","page":"DMRG FAQs","title":"Cases Where Periodic BC Seems Necessary, But Open/Infinite BC Can be Better","text":"","category":"section"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Below are some cases where periodic boundary conditions seem to be necessary at a first glance. But in many of these cases, not only can open or infinite boundaries be just as successful, they can even be the better choice.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Measuring asymptotic properties of correlation functions: much of our understanding of gapless one-dimensional systems comes from field-theoretic approaches which make specific predictions about asymptotic decays of various correlators. To test these predictions numerically, one must  work with large, translationally invariant systems with minimal edge effects. Using fully periodic boundary conditions satisfies these criteria. However, a superior choice is to use infinite DMRG, which combines the much better scaling of open-boundary DMRG with the ability to  measure correlators at arbitrarily long distances by repeating the unit cell of the MPS wavefunction. Although truncating to a finite number of states imposes an effective correlation length on the system, this correlation length can reach many thousands of sites for quite moderate MPS bond dimensions. Karrasch and Moore took advantage of this fact to convincingly check the predictions of Luttinger liquid theory for one-dimensional systems of gapless fermions.[Karrasch]","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Karrasch]: Luttinger liquid physics from the infinite-system density matrix renormalization group, C. Karrasch and J.E. Moore, Phys. Rev. B 86, 155156","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Studying two-dimensional topological order: a hallmark of intrinsic topological order is the presence of a robust ground state degeneracy when the system is put on a torus. Also many topological phases  have gapless edge states which can cause problems for numerical calculations. Thus one might think that fully periodic BC are the best choice for studying topological phases. However,  topological phases have the same ground-state degeneracy on an infinite cylinder as they do on a torus.[Zhang]. Cincio and Vidal exploited this fact to use infinite DMRG to study a variety of topological phases [Cincio]. One part of their calculation did actually require obtaining ground states on a torus, but they accomplished this by taking a finite segment of an infinite MPS  and connecting its ends. This approach does not give the true ground state of the torus but was sufficient  for their calculation and was arguably closer to the true two-dimensional physics.","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Zhang]: Quasiparticle statistics and braiding from ground-state entanglement, Yi Zhang, Tarun Grover, Ari Turner, Masaki Oshkawa, and Ashvin Vishwanath, Phys. Rev. B 85, 235151","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Cincio]: Characterizing Topological Order by Studying the Ground States on an Infinite Cylinder, L. Cincio and G. Vidal, Phys. Rev. Lett. 110, 067208","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"Obtaining bulk gaps: DMRG has the ability to \"target\" low-lying excited states or to obtain such states by constraining them to be orthogonal to the ground state. However, with OBC, localized excitations can get stuck to the edges and not reveal the true bulk gap behavior. Thus one may conclude that PBC is necessary. But using open or infinite boundaries remains the better choice because they allow much higher accuracy.\nTo deal with the presence of edges in OBC, one can use \"restricted sweeping\". Here one sweeps across the full system to obtain the ground state. Then, to obtain the first excited state one only sweeps through the full system to obtain the ground state. Then, to obtain the first excited state one only sweeps through the near the edges. This traps the particle in a \"soft box\" which still lets its wavefunction mix with the basis that describes the ground state outside the restricted sweeping region.\nWithin infinite DMRG, boundary effects are rigorously absent if the calculation has converged. To compute bulk gaps one again uses a type of restricted sweeping known in the literature as \"infinite boundary conditions\". For more see the work by Phien, Vidal, and McCulloch.[Phien]","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"[Phien]: Infinite boundary conditions for matrix product state calculations, Ho N. Phien, G. Vidal, and Ian P. McCulloch Phys. Rev. B 86, 245107","category":"page"},{"location":"faq/DMRG.html","page":"DMRG FAQs","title":"DMRG FAQs","text":"In conclusion, consider carefully whether you really need to use periodic boundary conditions, as they impose a steep computational cost within DMRG. Periodic BC can actually be worse for the very types of measurements where they are  often presented as the best or \"standard\" choice. Many of the issues periodic boundaries circumvent can be avoided more elegantly by using infinite DMRG, or when that is not applicable, by using open boundary conditions with sufficient care.","category":"page"},{"location":"tutorials/QN_DMRG.html#Quantum-Number-Conserving-DMRG","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"","category":"section"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"An important technique in DMRG calculations of quantum Hamiltonians is the conservation of quantum numbers. Examples of these are the total number of particles of a model of fermions, or the total of all S^z components of a system of spins. Not only can conserving quantum numbers make DMRG calculations run more quickly and use less memory, but it can be important for simulating physical systems with conservation laws and for obtaining ground states in different symmetry sectors. Note that ITensor currently only supports Abelian quantum numbers.","category":"page"},{"location":"tutorials/QN_DMRG.html#Necessary-Changes","page":"Quantum Number Conserving DMRG","title":"Necessary Changes","text":"","category":"section"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Setting up a quantum-number conserving DMRG calculation in ITensor requires only very small changes to a DMRG code. The main changes are:","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"using tensor indices (Index objects) which carry quantum number (QN) information to build your Hamiltonian and  initial state\ninitializing your MPS to have well-defined total quantum numbers","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Importantly, the total QN of your state throughout the calculation will remain the same as the initial state passed to DMRG. The total QN of your state is not set separately, but determined implicitly from the initial QN of the state when it is first constructed.","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Of course, your Hamiltonian should conserve all of the QN's that you would like to use. If it doesn't, you will get an error when you try to construct it out of the QN-enabled tensor indices.","category":"page"},{"location":"tutorials/QN_DMRG.html#Making-the-Changes","page":"Quantum Number Conserving DMRG","title":"Making the Changes","text":"","category":"section"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Let's see how to make these two changes to the DMRG Tutorial code from the previous section. At the end, we will put together these changes for a complete, working code.","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Change 1: QN Site Indices","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"To make change (1), we will change the line","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"sites = siteinds(\"S=1\",N)","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"by setting the conserve_qns keyword argument to true:","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"sites = siteinds(\"S=1\",N; conserve_qns=true)","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Setting conserve_qns=true tells the siteinds function to conserve every possible quantum number associated to the site type (which is \"S=1\" in this example). For S=1 spins, this will turn on total-S^z conservation. (For other site types that conserve multiple QNs, there are specific keyword arguments available to track just a subset of conservable QNs.) We can check this by printing out some of the site indices, and seeing that the subspaces of each Index are labeled by QN values:","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"@show sites[1]\n@show sites[2]","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Sample output:","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":" sites[1] = (dim=3|id=794|\"S=1,Site,n=1\") <Out>\n 1: QN(\"Sz\",2) => 1\n 2: QN(\"Sz\",0) => 1\n 3: QN(\"Sz\",-2) => 1\n sites[2] = (dim=3|id=806|\"S=1,Site,n=2\") <Out>\n 1: QN(\"Sz\",2) => 1\n 2: QN(\"Sz\",0) => 1\n 3: QN(\"Sz\",-2) => 1","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"In the sample output above, note that in addition to the dimension of these indices being 3, each of the three settings of the Index have a unique QN associated to them. The number after the QN on each line is the dimension of that subspace, which is 1 for each subspace of the Index objects above. Note also that \"Sz\" quantum numbers in ITensor are measured in units of 12, so QN(\"Sz\",2) corresponds to S^z=1 in conventional physics units.","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Change 2: Initial State","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"To make change (2), instead of constructing the initial MPS psi0 to be an arbitrary, random MPS, we will make it a specific state with a well-defined total S^z. So we will replace the line","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"psi0 = random_mps(sites;linkdims=10)","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"by the lines","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"state = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi0 = MPS(sites,state)","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"The first line of the new code above makes an array of strings which alternate between \"Up\" and \"Dn\" on odd and even numbered sites. These names \"Up\" and \"Dn\" are special values associated to the \"S=1\" site type which indicate up and down spin values. The second line takes the array of site Index objects sites and the array of strings state and returns an MPS which is a product state (classical, unentangled state) with each site's state given by the strings in the state array. In this example, psi0 will be a Neel state with alternating up and down spins, so it will have a total S^z of zero. We could check this by computing the quantum-number flux of psi0","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"@show flux(psi0)\n# Output: flux(psi0) = QN(\"Sz\",0)","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"info: Setting Other Total QN Values\nThe above example shows the case of setting a total \"Sz\" quantum number of zero, since the initial state alternates between \"Up\" and \"Dn\" on every site with an even number of sites.To obtain other total QN values, just set the initial state to be one which has the total QN you want. To be concrete let's take the example of a system with N=10 sites of S=1 spins.For example if you want a total \"Sz\" of +20 (= QN(\"Sz\",20)) in ITensor units, or S^z=10 in physical units, for a system with 10 sites, use the initial state:state = [\"Up\" for n=1:N]\npsi0 = MPS(sites,state)Or to initialize this 10-site system to have a total \"Sz\" of +16 in ITensor units (S^z=8 in physical units):state = [\"Dn\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\"]\npsi0 = MPS(sites,state)would work (as would any state with one \"Dn\" and nine \"Up\"'s in any order). Or you could initialize to a total \"Sz\" of +18 in ITensor units (S^z=9 in physical units) asstate = [\"Z0\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\"]\npsi0 = MPS(sites,state)where \"Z0\" refers to the S^z=0 state of a spin-one spin.Finally, the same kind of logic as above applies to other physical site types, whether \"S=1/2\", \"Electron\", etc.","category":"page"},{"location":"tutorials/QN_DMRG.html#Putting-it-All-Together","page":"Quantum Number Conserving DMRG","title":"Putting it All Together","text":"","category":"section"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"Let's take the DMRG Tutorial code from the previous section and make the changes discussed above, to turn it into a code which conserves the total S^z quantum number throughout the DMRG calculation. The resulting code is:","category":"page"},{"location":"tutorials/QN_DMRG.html","page":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","text":"using ITensors, ITensorMPS\nlet\n  N = 100\n  sites = siteinds(\"S=1\",N;conserve_qns=true)\n\n  os = OpSum()\n  for j=1:N-1\n    os += \"Sz\",j,\"Sz\",j+1\n    os += 1/2,\"S+\",j,\"S-\",j+1\n    os += 1/2,\"S-\",j,\"S+\",j+1\n  end\n  H = MPO(os,sites)\n\n  state = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\n  psi0 = MPS(sites,state)\n  @show flux(psi0)\n\n  nsweeps = 5\n  maxdim = [10,20,100,100,200]\n  cutoff = [1E-10]\n\n  energy, psi = dmrg(H,psi0; nsweeps, maxdim, cutoff)\n\n  return\nend","category":"page"}]
}
